# TIL

## 날짜: 2025-02-04

### 스크럼
- 학습 목표 1 : 프로세스, 스레드 정리

### 새로 배운 내용
#### 프로세스와 스레드
- 프로세스: 실행 중인 프로그램으로, 독립적인 실행 단위이며 운영 체제에서 별도의 메모리 공간을 가짐.
- 스레드: 프로세스 내에서 실행되는 작은 실행 단위로, 같은 프로세스 내 다른 스레드와 메모리를 공유.
- 프로세스 vs 스레드:
  - 프로세스는 독립적인 실행 단위로, 각 프로세스는 별도의 메모리 공간을 가짐.
  - 스레드는 프로세스 내에서 동작하며, 같은 프로세스 내 다른 스레드와 자원을 공유하기 때문에 더 가볍고 빠르게 실행 가능.

#### 컨텍스트 스위칭 (Context Switching)
- CPU가 현재 실행 중인 프로세스를 변경할 때, 현재 상태를 저장하고 새로운 프로세스를 불러오는 과정.
- 프로세스 간 컨텍스트 스위칭은 비용이 크며, 스레드 간 전환이 비교적 가벼움.
- 불필요한 컨텍스트 스위칭을 줄이는 것이 성능 최적화의 핵심.

#### 스레드 오버헤드 (Thread Overhead)
- 다중 스레드 환경에서는 컨텍스트 스위칭 및 동기화 비용이 추가됨.
- 스레드가 많아질수록 관리 비용이 증가하여, 오히려 성능 저하를 유발할 수도 있음.
- 적절한 스레드 수를 유지하는 것이 중요.

#### 자바에서 Thread 클래스 상속 vs Runnable 인터페이스
- Thread 클래스 상속:
  - 다른 클래스를 상속할 수 없으므로 유연성이 떨어짐.
- Runnable 인터페이스 구현:
  - 인터페이스이므로 다중 구현 가능.
  - 일반적으로 Runnable 사용이 더 권장됨.

#### 자바에서 지원하는 동시성 관리 방법
1. synchronized 키워드
   - 한 번에 하나의 스레드만 특정 코드 블록 또는 메서드에 접근할 수 있도록 제한. 
   - 임계 구역(critical section)을 보호하여 데이터 일관성을 유지.
2. AtomicInteger
   - 원자적 연산(Atomic Operation)을 제공하는 클래스. 
   - synchronized 없이도 멀티스레드 환경에서 안전하게 정수 연산 가능.
   - 성능이 synchronized보다 뛰어나며, CAS(Compare-And-Swap) 연산을 사용하여 동기화 비용을 줄임.
3. 기타 동시성 관리 방법
   - volatile 키워드: 가시성을 보장하지만 원자성은 보장하지 않음.
   - ReentrantLock: synchronized보다 세밀한 제어가 가능.
   - ExecutorService: 스레드 풀(Thread Pool)을 활용하여 효율적인 스레드 관리.

### 오늘의 도전 과제와 해결 방법
- 자바 스레드 실습
  - `join()` 은 스레드가 종료될 때까지 기다리는 역할만 하지, 여러 스레드가 동시에 실행될 때 공유 자원을 안전하게 보호하지는 않음
  - 즉 `join()` 을 써도 `value++` 연산이 원자적이지 않기 때문에 동시성 문제가 발생할 수 있음
  - 이 문제를 해결하기 위해 `syncronized` 나 `AtomicInteger` 를 써서 동시성 문제를 해결

### 오늘의 회고
- 프로세스/스레드에 대한 개념은 운영체제 교과목에서 배웠으나, 이를 직접 사용해 개발한 경험은 없다.
- 이론 지식을 공부할 때 어떤 상황에서 쓰이는지 명확히 짚고 넘어가야 함을 실감했다.
- 운영체제 복습도 한 번 해야겠다.