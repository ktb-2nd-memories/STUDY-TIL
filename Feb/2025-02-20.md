# TIL

## 날짜: 2025-02-20

### 스크럼
- 학습 목표 1 : 비동기(프로미스, Async/Await), 자바스크립트 엔진, 자바스크립트 런타임 환경, 스코프

### 새로 배운 내용

| **구분**                                         | **정의** | **비고** |
|------------------------------------------------| --- | --- |
| **Promise**                                    | 비동기 작업 (예: 서버 요청, 파일 읽기 등)의 완료 또는 실패를 나타내는 객체. `Promise()` 는 처음에 `pending(대기 상태)` 이며, 작업에 성공하면 `resolve()` 를 호출해 `fulfilled(이행 상태)` 로 변하고, 실패하면 `reject()` 를 호출해 `rejected(거부 상태)` 로 변함. | 기존의 `callback 함수` 방식보다 직관적이고 체계적인 비동기 처리를 가능하게 함. |
| **Promise 체인**                                 | `.then()` 메서드를 연속으로 사용하여 여러 비동기 작업을 순서대로 실행하는 방식. 각 `then()` 에서 값을 반환하면 다음 `then()` 에서 이를 받아 처리할 수 있음. | **예제:** `fetch('url').then(res => res.json()).then(data => console.log(data))` |
| **Promise의 상태**                                | `Promise` 는 3가지 상태를 가짐: <br> 1) `pending(대기)` - 초기 상태로 아직 결과가 없음. <br> 2) `fulfilled(이행)`  - 작업 성공, `resolve(value)` 호출됨. <br> 3) `rejected(거부)`  - 작업 실패, `reject(error)` 호출됨. | 한 번 `fulfilled` 또는 `rejected` 상태가 되면 다시 바뀌지 않음 (Immutable) |
| **Promise.all() 사용법**                          | 여러 개의 `Promise` 를 동시에 실행하고, **모두 성공할 경우** 결과를 배열로 반환하는 메서드. 하나라도 실패하면 `reject()` 를 호출함. | **예제:** <br> `Promise.all([p1, p2, p3]).then(results => console.log(results)).catch(error => console.error(error))` |
| **Async/Await <br> - 비동기/논블로킹 처리와 연관지어 이해할 것** | `async` 함수 내부에서 `await` 을 사용하면 비동기 코드를 동기식 코드처럼 실행할 수 있음. 즉 `await` 키워드는 `Promise` 가 처리될 때까지 기다려줌. |  |
| **자바스크립트 인터프리터**                               | 자바스크립트 코드를 한 줄씩 읽고 실행하는 프로그램. 브라우저(Chrome, Firefox 등) 또는 Node.js가 포함하고 있음. | 인터프리터 방식은 실행 속도가 빠르지만, 반복적인 실행에서 최적화가 필요함. |
| **자바스크립트 엔진**                                  | 자바스크립트 코드를 실행하는 핵심 소프트웨어. 대표적으로 Chrome의 `V8` , Firefox의 `SpiderMonkey` , Edge의 `Chakra` 등이 있음. | 엔진마다 최적화 방식이 달라 성능 차이가 발생할 수 있음. |
| **자바스크립트 엔진 - V8 엔진 내부 동작**                    | Google Chrome과 Node.js에서 사용되는 `V8 엔진` 은 자바스크립트 코드를 기계어로 변환하여 실행 속도를 높임 | 1) 파싱 - 자바스크립트 코드를 읽어서 추상 구문 트리(AST)로 변환함. <br> 2) 인터프리터 - `Ignition` 이라는 인터프리터가 AST를 읽고 바이트코드로 변환함. <br> 3) 최적화 컴파일 - `TurboFan` 이라는 최적화 컴파일러가 바이트코드를 최적화된 기계어로 변환함. 이때 JIT 컴파일러가 중요한 역할을 함. |
| **자바스크립트 엔진- JIT 컴파일러 역할** | 자바스크립트는 원래 인터프리터 방식이지만, 실행 속도를 높이기 위해 `JIT(Just-In-Time)` 컴파일러가 즉석에서 코드를 기계어로 변환하여 실행함. | 컴파일(미리 기계어로 변환)과 인터프리터 방식(실행하면서 변환)의 장점을 결합함. <br><br>- JIT 컴파일러의 최적화 단계 <br> 1) 프로파일링 - 코드를 실행하면서 자주 사용되는 함수(핫스팟)를 감지함. <br> 2) 최적화 컴파일 - `TurboFan` 컴파일러가 핫스팟 함수를 네이티브 기계어로 변환함. <br> 3) 디옵티마이제이션 - JIT 컴파일러가 최적화한 코드가 예상과 다르게 동작하면, 다시 일반 바이트코드 실행으로 되돌릴 수 있음. <br><br>- JIT 최적화 기법 <br> 1) 인라인 캐싱 - 자주 사용되는 함수의 결과를 캐싱하여 중복 연산을 줄임 <br> 2) 히든 클래스 - 자바스크립트는 동적 타입 언어이지만, V8은 내부적으로 클래스 구조를 만들어 속도를 향상시킴. |
| **렉시컬 스코프** | 선언된 위치에 따라 변수의 접근 범위가 달라지는 것. | 자바스크립트는 변수가 선언된 위치를 기준으로 해당 변수를 어디에서 접근할 수 있는지가 정해지므로 함수를 어디에서 호출했는지가 아니라, 어디에서 선언했느냐가 중요함. <br> **예제:** 함수 내부에서 선언된 변수는 외부에서 접근할 수 없음. |
| **스코프 체인** | 변수를 찾을 때 현재 스코프(블록/함수)에서 찾고, 없으면 한 단계 위(부모 스코프)로 이동하는 구조. | 1) 현재 함수(블록) 스코프에서 변수 찾기 <br> 2) 없으면 부모(외부) 스코프로 이동해서 찾기 <br> 3) 부모에서도 없으면 글로벌(전역) 스코프까지 탐색 <br> 4) 그래도 없으면 올 발생 (`ReferenceError)` <br><br> **예제:** `function outer() { let a = 10; function inner() { console.log(a); } inner(); } outer();` (출력: 10) |

### 1. promise는 무엇이고 콜백이랑 비교했을때 어떤 장점이 있는지 설명해 주세요.

### 2. promise의 세 가지 상태에 대해서 설명해 주세요.

### 3. then(), catch(), finally()의 차이와 사용 사례에 대해서 설명해 주세요.

### 4. promise chain의 개념과 장점에 대해서 설명해주세요.

### 5. promise.all()과 promise.allSettled()의 차이점

### 6. Aysnc메소드가 항상 Promise를 반환하는 이유

### 7. Async/Await가 동기 코드처럼 보이지만 실제로는 비동기/논블로킹 방식으로 동작하는 이유에 대해서 설명해 주세요.

### 8. V8 엔진의 JIT 컴파일러가 성능에 미치는 영향을 설명해 주세요.

### 9. 자바스크립트 코드 실행 과정에서 호이스팅이 발생하는 시점과 이유에 대해서 설명해 주세요.

### 10. 렉시컬 스코프와 실행 컨텍스트의 관계를 설명해 주세요.

### 11. 자바스크립트 엔진에서 스택과 힙의 역할 및 차이점에 대해서 설명해 주세요.

### 12. 자바스크립트의 스코프 체인이 변수 검색에 미치는 영향을 설명해 주세요.
