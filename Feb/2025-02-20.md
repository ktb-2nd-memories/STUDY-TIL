# TIL

## 날짜: 2025-02-20

### 스크럼
- 학습 목표 1 : 비동기(프로미스, Async/Await), 자바스크립트 엔진, 자바스크립트 런타임 환경, 스코프

### 새로 배운 내용

| **구분**                                         | **정의** | **비고** |
|------------------------------------------------| --- | --- |
| **Promise**                                    | 비동기 작업 (예: 서버 요청, 파일 읽기 등)의 완료 또는 실패를 나타내는 객체. `Promise()` 는 처음에 `pending(대기 상태)` 이며, 작업에 성공하면 `resolve()` 를 호출해 `fulfilled(이행 상태)` 로 변하고, 실패하면 `reject()` 를 호출해 `rejected(거부 상태)` 로 변함. | 기존의 `callback 함수` 방식보다 직관적이고 체계적인 비동기 처리를 가능하게 함. |
| **Promise 체인**                                 | `.then()` 메서드를 연속으로 사용하여 여러 비동기 작업을 순서대로 실행하는 방식. 각 `then()` 에서 값을 반환하면 다음 `then()` 에서 이를 받아 처리할 수 있음. | **예제:** `fetch('url').then(res => res.json()).then(data => console.log(data))` |
| **Promise의 상태**                                | `Promise` 는 3가지 상태를 가짐: <br> 1) `pending(대기)` - 초기 상태로 아직 결과가 없음. <br> 2) `fulfilled(이행)`  - 작업 성공, `resolve(value)` 호출됨. <br> 3) `rejected(거부)`  - 작업 실패, `reject(error)` 호출됨. | 한 번 `fulfilled` 또는 `rejected` 상태가 되면 다시 바뀌지 않음 (Immutable) |
| **Promise.all() 사용법**                          | 여러 개의 `Promise` 를 동시에 실행하고, **모두 성공할 경우** 결과를 배열로 반환하는 메서드. 하나라도 실패하면 `reject()` 를 호출함. | **예제:** <br> `Promise.all([p1, p2, p3]).then(results => console.log(results)).catch(error => console.error(error))` |
| **Async/Await <br> - 비동기/논블로킹 처리와 연관지어 이해할 것** | `async` 함수 내부에서 `await` 을 사용하면 비동기 코드를 동기식 코드처럼 실행할 수 있음. 즉 `await` 키워드는 `Promise` 가 처리될 때까지 기다려줌. |  |
| **자바스크립트 인터프리터**                               | 자바스크립트 코드를 한 줄씩 읽고 실행하는 프로그램. 브라우저(Chrome, Firefox 등) 또는 Node.js가 포함하고 있음. | 인터프리터 방식은 실행 속도가 빠르지만, 반복적인 실행에서 최적화가 필요함. |
| **자바스크립트 엔진**                                  | 자바스크립트 코드를 실행하는 핵심 소프트웨어. 대표적으로 Chrome의 `V8` , Firefox의 `SpiderMonkey` , Edge의 `Chakra` 등이 있음. | 엔진마다 최적화 방식이 달라 성능 차이가 발생할 수 있음. |
| **자바스크립트 엔진 - V8 엔진 내부 동작**                    | Google Chrome과 Node.js에서 사용되는 `V8 엔진` 은 자바스크립트 코드를 기계어로 변환하여 실행 속도를 높임 | 1) 파싱 - 자바스크립트 코드를 읽어서 추상 구문 트리(AST)로 변환함. <br> 2) 인터프리터 - `Ignition` 이라는 인터프리터가 AST를 읽고 바이트코드로 변환함. <br> 3) 최적화 컴파일 - `TurboFan` 이라는 최적화 컴파일러가 바이트코드를 최적화된 기계어로 변환함. 이때 JIT 컴파일러가 중요한 역할을 함. |
| **자바스크립트 엔진- JIT 컴파일러 역할** | 자바스크립트는 원래 인터프리터 방식이지만, 실행 속도를 높이기 위해 `JIT(Just-In-Time)` 컴파일러가 즉석에서 코드를 기계어로 변환하여 실행함. | 컴파일(미리 기계어로 변환)과 인터프리터 방식(실행하면서 변환)의 장점을 결합함. <br><br>- JIT 컴파일러의 최적화 단계 <br> 1) 프로파일링 - 코드를 실행하면서 자주 사용되는 함수(핫스팟)를 감지함. <br> 2) 최적화 컴파일 - `TurboFan` 컴파일러가 핫스팟 함수를 네이티브 기계어로 변환함. <br> 3) 디옵티마이제이션 - JIT 컴파일러가 최적화한 코드가 예상과 다르게 동작하면, 다시 일반 바이트코드 실행으로 되돌릴 수 있음. <br><br>- JIT 최적화 기법 <br> 1) 인라인 캐싱 - 자주 사용되는 함수의 결과를 캐싱하여 중복 연산을 줄임 <br> 2) 히든 클래스 - 자바스크립트는 동적 타입 언어이지만, V8은 내부적으로 클래스 구조를 만들어 속도를 향상시킴. |
| **렉시컬 스코프** | 선언된 위치에 따라 변수의 접근 범위가 달라지는 것. | 자바스크립트는 변수가 선언된 위치를 기준으로 해당 변수를 어디에서 접근할 수 있는지가 정해지므로 함수를 어디에서 호출했는지가 아니라, 어디에서 선언했느냐가 중요함. <br> **예제:** 함수 내부에서 선언된 변수는 외부에서 접근할 수 없음. |
| **스코프 체인** | 변수를 찾을 때 현재 스코프(블록/함수)에서 찾고, 없으면 한 단계 위(부모 스코프)로 이동하는 구조. | 1) 현재 함수(블록) 스코프에서 변수 찾기 <br> 2) 없으면 부모(외부) 스코프로 이동해서 찾기 <br> 3) 부모에서도 없으면 글로벌(전역) 스코프까지 탐색 <br> 4) 그래도 없으면 올 발생 (`ReferenceError)` <br><br> **예제:** `function outer() { let a = 10; function inner() { console.log(a); } inner(); } outer();` (출력: 10) |

### 1. promise는 무엇이고 콜백이랑 비교했을때 어떤 장점이 있는지 설명해 주세요.

Promise는 자바스크립트에서 비동기 작업을 처리하는 객체로, 미래에 완료될 작업의 성공과 실패를 표현하는 방식입니다.

콜백 함수와 비교했을 때, Promise는 두 가지 주요 장점이 있습니다.

첫 번째로, **가독성과 코드 구조가 개선됩니다.** 콜백 방식은 중첩 구조(콜백 지옥)로 인해 코드가 복잡해지지만, Promise는 `.then()`과 `.catch()`를 활용해 흐름을 직관적으로 표현할 수 있습니다. 또한, `.then()` 체이닝을 통해 여러 비동기 작업을 논리적으로 연결할 수 있어 코드가 깔끔하고 유지보수하기 쉽습니다.

두 번째로, **에러 처리가 간편합니다.** 콜백 방식은 각 단계별로 개별적으로 오류를 처리해야 하지만, Promise는 `.catch()` 하나만으로 체이닝된 모든 오류를 한 번에 처리할 수 있어 예외 처리가 효율적입니다.

결론적으로, Promise는 가독성과 유지보수성을 개선하면서 비동기 코드를 더 구조적으로 관리할 수 있는 방식입니다.

### 2. promise의 세 가지 상태에 대해서 설명해 주세요.

첫 번째로, pending 상태입니다. pending은 promise가 생성된 직후 초기 상태입니다. 아직 결과가 확정되지 않았으며, 비동기 작업이 진행 중입니다.

두 번째로, fulfilled 상태입니다. 비동기 작업이 완료되고, `resolve(value)` 가 호출된 상태입니다. 이 상태가 되면 `.then()` 블록이 실행되어 결과 값을 처리할 수 있습니다.

세 번째로, rejected 상태입니다. 비동기 작업이 실패하고, `reject(error)` 가 호출된 상태입니다. 이 상태에서는 `.catch()` 를 통해 에러를 처리할 수 있습니다.

즉, Promise는 처음 `pending` 상태로 시작해서, 작업이 완료되면 `fulfilled` 또는 `rejected` 상태로 변하며, 한 번 상태가 결정되면 변경되지 않습니다.

### 3. then(), catch(), finally()의 차이와 사용 사례에 대해서 설명해 주세요.

첫 번째로, `then()` 은 promise가 성공(fulfilled)했을 때 실행되는 메서드로, 비동기 작업이 완료된 후 결과 값을 받아 처리할 수 있습니다. 예를 들어, 서버에서 데이터를 요청하는 경우, 응답을 받아 원하는 형태로 변환하거나 화면에 표시하는 역할을 합니다. 또한 `then()` 을 연속으로 사용하면 여러 개의 비동기 작업을 순차적으로 실행할 수 있습니다.

두 번째로, `catch()` 는 promise가 실패(rejected)했을 때 실행되는 메서드입니다. 네트워크 오류나 잘못된 요청으로 인해 promise가 거부될 경우, `catch()` 를 사용해 오류를 감지하고 적절한 예외 처리를 할 수 있습니다. 특히, `then()` 내부에서 오류가 발생해도 `catch()` 에서 이를 한 번에 처리할 수 있기 때문에 유지보수 측면에서도 유용합니다.

세 번째로, `finally()` 는 promise의 성공 여부와 상관없이 무조건 실행되는 메서드입니다. 예를 들어, 서버 요청이 성공하든 실패하든 로딩 화면을 닫거나, 연결을 종료하는 등 후처리가 필요할 때 사용됩니다.

즉, `then()`은 성공한 경우 실행되며, `catch()`는 실패한 경우 실행되고, `finally()`는 성공 여부와 관계없이 항상 실행됩니다. 따라서, `then()`은 데이터 처리, `catch()`는 오류 처리, `finally()`는 정리 작업을 수행하는 용도로 사용됩니다.

### 4. promise chain의 개념과 장점에 대해서 설명해주세요.

promise chain은 여러 개의 비동기 작업을 `.then()` 을 이용해 순차적으로 실행하는 방식입니다. 즉, 하나의 `then()` 에서 값을 반환하면, 다음 `then()` 에서 이를 받아 이어서 처리할 수 있습니다. 이를 통해 비동기 작업을 단계적으로 연결하여 논리적인 흐름을 만들 수 있습니다.

장점으로는,

첫 번째로, 기존의 콜백 방식에서는 비동기 작업이 중첩되면서 코드의 들여쓰기가 깊어지는 “콜백 지옥”이 발생할 수 있습니다. 하지만 Promise Chain을 사용하면 각  `then()`  블록이 순차적으로 실행되므로 코드가 더 깔끔하고 이해하기 쉬워집니다.

두 번째로, 콜백 방식에서는 각 단계마다 개별적으로 오류를 처리해야 하지만, Promise Chain에서는 마지막에 `catch()` 하나만 추가하면 모든 비동기 작업에서 발생한 오류를 한 번에 처리할 수 있습니다.

세 번째로, 여러 개의 비동기 작업이 있을 때, 이전 작업이 완료된 후에만 다음 작업이 실행되도록 설정할 수 있습니다. 예를 들어, 서버에서 데이터를 가져온 후, 이를 가공하고, 마지막으로 화면에 출력하는 흐름을 자연스럽게 만들 수 있습니다.

즉, Promise Chain은 가독성을 높이고, 에러 처리를 간편하게 하며, 비동기 작업을 단계적으로 연결할 수 있도록 도와주는 방식입니다.

### 5. promise.all()과 promise.allSettled()의 차이점

첫 번째로, `promise.all()` 은 여러 개의 promise를 동시에 실행하고, 모든 promise가 성공해야만 결과를 반환하는 메서드입니다. 만약 하나라도 실패하면 즉시 `reject` 가 발생하고, 나머지 promise의 결과는 무시됩니다. 따라서, `promise.all()` 은 모든 작업이 반드시 성공해야 하는 경우에 적합합니다.

두 번째로, `promise.allSettled()` 도 마찬가지로 여러 개의 promise를 동시에 실행하지만, 각 promise의 성공 여부와 관계없이 모든 결과를 반환하는 메서드입니다. 성공한 경우 `fulfilled` , 실패한 경우 `rejected` 상태로 각각 결과를 받을 수 있습니다. 따라서, 일부 작업이 실패하더라도 모든 결과를 확인해야 하는 경우에 적합합니다.

따라서, `Promise.all()`은 모든 작업이 반드시 성공해야 하는 경우에 사용하고, `Promise.allSettled()`는 일부 작업이 실패하더라도 전체 결과를 확인해야 하는 경우에 유용합니다.

### 6. Aysnc메소드가 항상 Promise를 반환하는 이유

첫 번째로, 비동기 코드의 일관성을 유지하기 위해서입니다. 자바스크립트는 비동기 작업을 `Promise` 기반으로 처리합니다. `async` 함수가 항상 `Promise`를 반환하면, `.then()`, `.catch()`, `await`을 활용해 일관된 방식으로 비동기 작업을 제어할 수 있습니다.

두 번째로, 예외 처리를 일원화할 수 있기 때문입니다. `async` 함수 내부에서 오류가 발생하면 자동으로 `Promise.reject()`로 변환됩니다. 이를 통해 `try-catch`나 `.catch()`를 사용하여 예외를 효과적으로 관리할 수 있습니다.

즉, `async` 함수가 항상 `Promise`를 반환하는 이유는 비동기 코드의 일관성을 유지하고, 예외 처리를 체계적으로 관리하기 위해서입니다.

### 7. Async/Await가 동기 코드처럼 보이지만 실제로는 비동기/논블로킹 방식으로 동작하는 이유에 대해서 설명해 주세요.

https://www.youtube.com/watch?v=8aGhZQkoFbQ

https://www.korecmblog.com/blog/node-js-event-loop

https://velog.io/@surim014/event-loop-in-nodejs

https://velog.io/@kcj_dev96/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%ACWeb-API-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-web-api%EC%99%80-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C%EB%8A%94-%EB%AC%B4%EC%8A%A8-%EA%B4%80%EA%B3%84%EC%9D%BC%EA%B9%8C

async/await은 promise 기반의 비동기 처리 방식입니다. `await` 키워드는 특정 `promise` 가 해결될 때까지 기다리는 것처럼 보이지만, 실제로는 자바스크립트 엔진의 이벤트 루프와 마이크로태스크 큐를 활용하여 논블로킹 방식으로 동작합니다.

즉, `await` 를 만나면 해당 `promise` 가 완료될 때까지 실행 컨텍스트가 빠져나오고, 그동안 자바스크립트는 UI 업데이트나 이벤트 처리 같은 다른 작업을 계속 수행할 수 있습니다. 이후, 해당 `promise` 가 해결되면 마이크로태스크 큐에서 다시 실행되며 코드의 흐름이 동기처럼 보이지만 실제로는 비동기적으로 처리됩니다.

### 8. V8 엔진의 JIT 컴파일러가 성능에 미치는 영향을 설명해 주세요.

첫 번째로, JIT 컴파일러는 자바스크립트 실행 속도를 크게 향상시킵니다. 기본적을 자바스크립트는 인터프리터 방식으로 실행되지만, JIT 컴파일러는 실행 중에 코드를 기계어로 변환하여 인터프리팅보다 훨씬 빠른 속도를 제공합니다.

두 번째로, 동적 최적화를 통해 코드 실행 성능을 개선합니다. V8 엔진의 JIT 컴파일러는 실행 중인 코드의 패턴을 분석하고, 자주 실행되는 코드인 핫스팟을 최적화하여 성능을 향상시킵니다. 예를 들어, 인라인 캐싱 기법을 사용해 반복적인 속성 접근을 최적화함으로써 실행 속도를 높입니다.

세 번째로, 필요할 때만 최적화된 코드를 생성하여 효율적인 메모리 사용이 가능합니다. V8의 JIT 컴파일러는 실행 도중 성능이 중요한 코드만 기계어로 변환하고, 필요하지 않은 경우 다시 인터프리팅 방식으로 되돌리는 디옵티마이제이션을 수행합니다. 이를 통해 메모리 사용을 최적화하고, 불필요한 컴파일을 방지하여 실행 효율을 극대화할 수 있습니다.

즉, V8 엔진의 JIT 컴파일러는 인터프리터 방식과 컴파일 방식의 장점을 결합하여 실행 속도를 높이고, 동적 최적화 및 메모리 효율화를 통해 전반적인 성능을 개선합니다.

### 9. 자바스크립트 코드 실행 과정에서 호이스팅이 발생하는 시점과 이유에 대해서 설명해 주세요.

첫 번째로, 호이스팅(Hoisting)이란 자바스크립트에서 변수와 함수 선언이 실행 전에 메모리에 미리 할당되는 현상입니다. 즉, 코드가 실행되기 전에 선언된 변수와 함수가 먼저 메모리에 올라가므로, 선언보다 먼저 접근하는 것이 가능합니다.

두 번째로, 호이스팅이 발생하는 시점은 코드 실행 이전, 즉 “메모리 할당 단계(Execution Context 생성 시점)”입니다. 자바스크립트 엔진은 코드를 실행하기 전에 실행 컨텍스트(Execution Context)를 생성하면서, 변수와 함수의 선언을 먼저 등록한 후, 이후에 코드 실행을 시작합니다.

세 번째로, 호이스팅이 발생하는 이유는 자바스크립트의 실행 방식 때문입니다. 자바스크립트는 두 단계로 코드를 실행하는데,

첫 번째로, 메모리 할당 단계에서 실행 전에 변수와 함수 선언을 미리 등록합니다.

두 번째로, 실제 실행 단계에서 코드가 순차적으로 실행되는데, 이 과정에서 `var` 로 선언된 변수는 초기화되지 않은 상태(undefined)로 올라가고, `let` 과 `const` 는 TDZ(Temporal Dead Zone, 일시적 사각지대)에 존재하여 초기화 전에는 접근할 수 없습니다.

즉, 호이스팅은 실행 컨텍스트가 생성되는 시점에서 발생하며, 코드 실행 전에 변수와 함수 선언을 메모리에 먼저 등록하는 과정에서 나타납니다.

### 10. 렉시컬 스코프와 실행 컨텍스트의 관계를 설명해 주세요.

첫 번째로, 렉시컬 스코프(Lexical Scope)는 “함수가 선언된 위치”에 따라 변수의 접근 범위가 결정되는 규칙입니다. 즉, “함수를 어디에서 호출했느냐”가 아니라, “어디에서 선언했느냐”가 중요한데요, 자바스크립트는 함수가 선언된 시점에서의 스코프 체인(변수 접근 경로)을 기억하며, 실행할 때도 이 정보를 기반으로 변수를 찾습니다.

두 번째로, 실행 컨텍스트(Execution Context)는 코드가 실행될 때 생성되는 환경입니다. 자바스크립트는 함수가 실행될 때마다 실행 컨텍스트를 생성하고, 현재 함수가 접근할 수 있는 변수와 실행 흐름을 관리합니다. 이때, 실행 컨텍스트 내부에는 “렉시컬 환경(Lexical Envirionment)”이 포함되어 있으며, 이를 통해 해당 함수가 선언된 위치를 기준으로 스코프를 결정합니다.

세 번째로, 렉시컬 스코프는 실행 컨텍스트 내에서 스코프 체인으로 구현됩니다. 실행 컨텍스트가 생성될 때, 현재 함수의 렉시컬 환경과 부모 스코프의 렉시컬 환경이 연결되어 스코프 체인이 만들어집니다. 즉, 렉시컬 스코프는 실행 컨텍스트 내부에서 변수 탐색이 이루어지는 방식이며, 실행 컨텍스트는 이를 관리하는 역할을 합니다.

즉, 렉시컬 스코프는 “어디서 선언되었는지”를 기준으로 변수 접근 범위를 결정하고, 실행 컨텍스트는 이를 기반으로 실행 시점에서 변수 탐색을 수행하는 관계입니다.

### 11. 자바스크립트 엔진에서 스택과 힙의 역할 및 차이점에 대해서 설명해 주세요.

첫 번째로, 스택(Stack)은 함수 실행 컨텍스트와 기본형 데이터(Primitive Type)가 저장되는 메모리 공간입니다. 자바스크립트는 함수가 호출될 때마다 실행 컨텍스트를 생성하며, 이를 콜 스택(Call Stack) 에 추가합니다. 함수 실행이 끝나면 스택에서 제거되며, LIFO(Last In, First Out, 후입선출) 구조로 동작합니다.

두 번째로, 힙(Heap)은 객체(Object), 배열(Array), 함수(Function) 같은 참조형 데이터(Reference Type)가 저장되는 메모리 공간입니다. 힙 메모리는 구조적으로 자유롭게 할당되며, 필요할 때마다 동적으로 생성됩니다. 이러한 데이터는 스택이 아닌 힙에 저장되고, 해당 참조 값이 스택에 위치합니다.

세 번째로, 스택과 힙의 차이점은 데이터 저장 방식과 메모리 관리 방식에서 나타납니다. 스택(Stack) 은 빠르게 메모리를 할당하고 해제할 수 있지만, 크기가 제한적이며 주로 함수 실행과 관련된 데이터를 저장합니다. 힙(Heap) 은 크기가 동적으로 관리되며, 가비지 컬렉션(Garbage Collection)에 의해 필요하지 않은 메모리를 해제합니다. 하지만 구조적으로 스택보다 메모리 접근 속도가 상대적으로 느립니다.

즉, 스택은 실행 컨텍스트와 기본형 데이터를 저장하며 빠르게 관리되지만, 힙은 동적으로 생성된 객체를 저장하며 가비지 컬렉션을 통해 관리됩니다.

### 12. 자바스크립트의 스코프 체인이 변수 검색에 미치는 영향을 설명해 주세요.

첫 번째로, 스코프 체인(Scope Chain)은 변수를 검색할 때 현재 스코프에서 찾고, 없으면 상위 스코프로 이동하는 구조입니다. 자바스크립트는 함수를 중첩해서 사용할 수 있기 때문에, 내부 함수는 외부 함수의 변수에 접근할 수 있습니다. 이러한 변수를 찾는 과정이 스코프 체인을 통해 이루어집니다.

두 번째로, 스코프 체인은 렉시컬 스코프(Lexical Scope)를 기반으로 동작합니다. 렉시컬 스코프란 변수가 선언된 위치를 기준으로 스코프가 결정된다는 개념입니다. 즉, 함수를 어디에서 호출했느냐가 아니라, 어디에서 선언했느냐에 따라 접근할 수 있는 변수의 범위가 결정됩니다.

세 번째로, 스코프 체인은 변수 검색의 우선순위를 결정합니다. 변수를 사용할 때, 자바스크립트 엔진은 먼저 현재 스코프에서 변수를 찾고, 없으면 부모 스코프로 이동하며, 전역 스코프까지 탐색합니다. 만약 전역 스코프까지 찾아도 변수를 찾지 못하면 `ReferenceError`가 발생합니다.

즉, 스코프 체인은 변수를 검색할 때 가장 가까운 스코프부터 차례로 탐색하는 방식이며, 이를 통해 변수의 접근 가능 범위와 우선순위를 결정합니다.
