# TIL

## 날짜: 2025-02-25

### 스크럼
- 학습 목표 1 : 실행 컨텍스트, this, 클로저, 프로토타입

### 1. Execution Context

JavaScript 코드가 실행될 때 생성되는 환경을 의미합니다. JavaScript 엔진은 코드를 실행하기 전에 먼저 Execution Context를 생성하며, 이 안에는 실행에 필요한 변수, 함수, 스코프 등이 포함됩니다. Execution Context는 크게 전역 실행 컨텍스트, 함수 실행 컨텍스트, 그리고 eval 실행 컨텍스트로 나뉩니다.

### 2. 전역 실행 컨텍스트 / 함수 실행 컨텍스트

전역 실행 컨텍스트는 JavaScript 코드가 실행될 때 가장 먼저 생성되는 실행 환경입니다. 자바스크립트 엔진이 스크립트를 실행하면 자동으로 생성되며, 하나의 프로그램에는 단 하나의 전역 실행 컨텍스트만 존재합니다. 전역 실행 컨텍스트는 전역 객체, 전역 변수, 그리고 전역에서 선언된 함수를 포함합니다. 이 전역 실행 컨텍스트는 프로그램이 종료될 때까지 유지되며, 실행 컨텍스트 스택의 최상단에 위치하게 됩니다.

함수 실행 컨텍스트는 함수가 호출될 때마다 생성되는 실행 환경입니다. 함수가 호출될 때마다 생성되는 실행 환경입니다. 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되며, 해당 함수가 종료되면 실행 컨텍스트 스택에서 제거됩니다. 함수 실행 컨텍스트에는 함수 내부에서 선언된 변수, 매개변수, 내부 함수, 그리고 함수 실행과 관련된 this 바인딩 정보가 포함됩니다. 함수 실행 컨텍스트는 함수가 호출될 때마다 새롭게 생성되므로, 동일한 함수가 여러 번 호출되면 각 호출마다 개별적인 실행 컨텍스트가 생성됩니다. 실행이 끝난 후에는 스택에서 제거되어 메모리에서 해제됩니다.

### 3. 콜스택 과정

콜 스택은 자바스크립트 엔진이 실행 컨텍스트를 관리하는 자료구조로, 함수가 호출되는 순서와 실행이 끝난 후 반환되는 과정을 추적하는 역할을 합니다. 콜 스택은 후입선출 구조로 동작하며, 실행 컨텍스트가 추가될 때는 스택의 맨 위에 쌓이고, 실행이 끝나면 스택에서 제거됩니다.

자바스크립트 코드가 실행될 때, 가장 먼저 전역 실행 컨텍스트가 콜 스택에 추가됩니다. 이후 함수가 호출될 때마다 새로운 함수 실행 컨텍스트가 생성되어 스택의 맨 위에 추가됩니다. 함수의 실행이 끝나면 해당 실행 컨텍스트는 스택에서 제거되며, 다시 이전 실행 컨텍스트로 돌아가 실행을 계속합니다. 만약 함수가 또 다른 함수를 호출하면, 새 함수의 실행 컨텍스트가 스택의 맨 위에 추가되고, 실행이 끝나야 제거됩니다.

콜 스택이 정상적으로 동작할 경우, 실행이 긑난 함수의 컨텍스트가 차례로 제거되면서 스택이 비워집니다. 하지만 콜 스택의 크기가 제한되어 있으므로 무한 재귀 호출이나 끝나지 않는 함수 호출이 반복될 경우, 실행 컨텍스트가 계속해서 스택에 추가되면서 “Maximum call stack size exceeded”라는 오류가 발생할 수 있습니다.

### 4. 스코프 체인

스코프 체인은 자바스크립트에서 변수와 함수에 접근할 수 있는 규칙을 정의하는 개념으로, 실행 컨텍스트와 연관되어 있습니다. 자바스크립트는 렉시컬 스코프를 따르며, 이는 변수가 선언된 위치에 따라 스코프가 결정된다는 의미입니다.

스코프 체인은 특정 실행 컨텍스트에서 변수를 찾을 때, 해당 컨텍스트에서 먼저 변수를 검색하고, 만약 존재하지 않으면 부모 스코프로 올라가면서 찾는 방식으로 동작합니다. 즉, 가장 가까운 스코프에서 변수를 찾지 못하면 상위 스코프로 이동하는 구조입니다. 이러한 과정은 최상위 스코프인 전역 실행 컨텍스트에 도달할 때까지 반복됩니다.

스코프 체인을 활용하면 변수의 접근 범위를 명확하게 관리할 수 있으며, 네임스페이스의 충돌을 방지하고 코드의 모듈성을 높일 수 있습니다. 다만, 불필요한 전역 변수 사용을 줄이고, 클로저와 같은 개념을 적절히 활용해야 성능 저하를 방지할 수 있습니다.

### 5. 변수 호이스팅 / 함수 호이스팅

변수 호이스팅은 `var` , `let` , `const` 로 선언된 변수에 따라 다르게 동작합니다. `var` 로 선언된 변수는 선언과 동시에 `undefined` 로 초기화되며, 선언된 위치와 관계없이 코드의 최상단으로 끌어올려진 것처럼 동작합니다. 하지만 `let` 과 `const` 로 선언된 변수는 선언만 호이스팅되지만 초기화는 이루어지지 않아, 선언 전에 접근하려고 하면 “ReferenceError”가 발생합니다. 이는 TDZ라는 개념 때문입니다.

함수 호이스팅은 함수 선언문과 함수 표현식에 따라 동작 방식이 다릅니다. 함수 선언문으로 정의된 함수는 코드의 어디에서든 호출할 수 있도록 실행 컨텍스트의 생성 단계에서 메모리에 저장됩니다. 반면, 함수 표현식은 변수에 함수가 할당되는 방식이므로, 해당 변수가 초기화되기 전에는 함수를 호출할 수 없습니다. 따라서 함수 표현식을 선언 전에 호출하면 “TypeError”가 발생합니다.

### 6. this

`this` 는 자바스크립트에서 실행 컨텍스트에 따라 동적으로 결정되는 객체를 가리키는 키워드입니다.

### 7. 바인딩 결정 방식 정리

전역에서는 전역 객체를, 객체의 메서드에서는 해당 객체를, 생성자 함수에서는 새로 생성된 인스턴스를, 화살표 함수에서는 상위 스코프의 `this` 를 참조합니다.

### 8. call, apply, bind 메소드

call, apply, bind는 자바스크립트에서 함수의 `this` 를 명시적으로 지정할 때 사용하는 메서드입니다.

call은 함수를 호출하면서 `this` 를 지정하고, 추가적인 인수를 개별적으로 전달합니다.

apply는 call과 유사하지만, 인수를 배열 형태로 전달합니다.

bind는 `this` 를 지정한 새로운 함수를 반환하며, 즉시 실행되지 않고 나중에 호출할 수 있습니다.

### 9. arrow function과 일반 함수의 this 차이

화살표 함수와 일반 함수의 `this` 는 동작 방식이 다릅니다.

일반 함수의 `this` 는 함수가 호출되는 방식에 따라 동적으로 결정됩니다. 전역에서 호출하면 전역 객체를 가리키고, 객체의 메서드로 호출하면 해당 객체를 가리킵니다. 하지만 `strict mode` 에서는 `undefined` 가 될 수도 있습니다.

반면, 화살표 함수의 `this` 는 정적으로 결정되며, 자신을 포함하는 상위 스코프의 `this` 를 그대로 상속합니다. 즉, 실행 컨텍스트에 따라 변하지 않고, 호출 방식과 관계없이 선언될 때의 `this` 를 유지합니다. 이 때문에 화살표 함수는 call, apply, bind로 `this` 를 변경할 수 없습니다.

### 10. 클로저

클로저는 함수와 그 함수가 선언된 렉시컬 환경을 함께 기억하는 함수입니다. 함수가 생성될 때의 스코프를 기억하기 때문에, 내부 함수가 외부 함수의 변수에 접근할 수 있으며, 외부 함수 실행이 끝난 후에도 해당 변수를 계속 유지할 수 있습니다. 클로저는 데이터 은닉, 상태 유지, 함수형 프로그래밍 등에 활용됩니다.

### 11. 클로저 장단점 및 메모리 관리 이슈

클로저는 함수가 선언될 당시의 렉시컬 환경을 기억하고, 외부 함수의 변수를 내부 함수에서 계속 접근할 수 있도록 해주는 개념입니다. 이를 활용하면 데이터를 은닉하거나 특정 상태를 유지할 수 있어 모듈화된 코드 작성이 용이합니다. 하지만 클로저는 외부 변수의 참조를 유지하기 때문에 불필요한 변수가 계속 메모리에 남아 있을 경우 메모리 누수가 발생할 수 있습니다. 이를 방지하려면 사용이 끝난 클로저의 참조를 명확히 제거하거나 변수 값을 null로 설정하는 방식으로 관리해야 합니다.

### 12. 클로저를 활용한 모듈 패턴

클로저를 활용한 모듈 패턴은 내부 데이터를 외부에서 직접 접근할 수 없도록 보호하면서 필요한 기능만 외부에 제공하는 방식입니다. 즉, 즉시 실행 함수 표현식(IIFE)이나 객체 리터럴을 사용하여 변수를 클로저 내부에 감추고, 반환된 객체를 통해 필요한 메서드만 접근할 수 있도록 합니다. 이를 통해 데이터 은닉이 가능하며, 전역 네임스페이스 오염을 방지하고 코드의 모듈성을 높일 수 있습니다.

### 13. 프로토타입

프로토타입은 자바스크립트에서 객체가 상속을 구현하는 방식으로, 모든 객체는 프로토타입 객체를 상속받아 해당 객체의 속성과 메서드를 사용할 수 있습니다. 객체는 `__proto__` 를 통해 부모 프로토타입을 참조하며, 이를 통해 프로토타입 체인이 형성됩니다. 이를 활용하면 코드 재사용이 가능하고 메모리를 효율적으로 관리할 수 있습니다.

### 14. 프로토타입 체인

프로토타입 체인은 객체가 특정 속성이나 메서드를 찾을 때, 해당 객체에서 찾지 못하면 상위 프로토타입을 따라가며 검색하는 구조를 의미합니다. 자바스크립트에서 모든 객체는 `__proto__` 를 통해 부모 프로토타입을 참조하며, 최종적으로 `Object.prototype` 에 도달하게 됩니다. 만약 프로토타입 체인 상 어디에도 해당 속성을 찾지 못하면 `undefined` 를 반환합니다. 이 구조를 활용하면 객체 간 속성과 메서드를 공유할 수 있어 메모리를 절약하고 코드 재사용성을 높일 수 있습니다.

### 15. class와 프로토타입의 차이

`prototype` 은 객체의 상속을 구현하기 위해 사용되며, 객체가 다른 객체의 속성과 메서드를 공유할 수 있도록 합니다. 프로토타입을 사용하면 함수의 `prototype` 속성에 메서드를 추가하여 해당 함수를 통해 생성된 모든 객체가 공유할 수 있도록 만들 수 있습니다.

반면, `class` 는 ES6에서 도입된 문법으로, 기존의 프로토타입 기반 상속을 더 직관적이고 읽기 쉽게 만든 것입니다. `class` 를 사용하면 `constructor` 를 통해 객체를 생성하고, `extends` 키워드를 사용하여 상속을 구현할 수 있으며, 내부적으로는 여전히 `prototype` 을 이용해 동작합니다.

즉, `prototype` 은 직접 객체의 프로토타입을 수정하여 상속을 구현하는 방식이고, `class` 는 이를 보다 간결하게 표현하는 문법적 설탕이지만, 결국 내부적으로는 프로토타입을 기반으로 동작합니다.