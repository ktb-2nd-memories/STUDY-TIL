# TIL

## 날짜: 2025-03-04

### 스크럼
- 학습 목표 1 : 데이터베이스, 정규화, SQL 기초, SQL 응용

### 1. 일관성과 무결성의 차이

일관성과 무결성의 차이는 데이터의 유지 기준에서 나타납니다. 일관성(Consistency)은 데이터가 정의된 규칙과 제약 조건을 항상 만족하는 것을 의미하며, 트랜잭션 수행 전후에 데이터의 유효성이 유지되는 것을 보장합니다. 반면, 무결성(Integrity)은 데이터의 정확성과 신뢰성을 유지하는 개념으로, 기본 키, 외래 키, 도메인 제약 조건 등을 통해 데이터의 정합성을 보장합니다. 즉, 일관성은 트랜잭션 처리 과정에서 데이터가 변형될 때도 규칙을 준수하는 것을 의미하고, 무결성은 데이터 자체가 정확하고 신뢰할 수 있도록 유지되는 것을 의미합니다.

### 2. key의 종류

기본키는 테이블 내에서 각 행을 고유하게 식별하는 키이며, NULL 값을 가질 수 없습니다.

후보키는 기본키가 될 수 있는 후보 중 하나이며, 기본키는 후보키 중에서 선택됩니다.

대체키는 후보 키 중에서 기본 키로 선택되지 않은 키입니다.

외래키는 다른 테이블의 기본키를 참조하는 키로, 데이터의 무결성을 보장하는 데 사용됩니다.

### 3. 정규화 / 역정규화

정규화는 데이터 중복을 최소화하고, 데이터의 일관성을 유지하기 위해 테이블을 분리하는 과정입니다. 일반적으로 1NF부터 3NF까지 진행되며, 3NF를 넘어가면 BCNF나 4NF도 고려할 수 있습니다.

역정규화는 성능을 향상시키기 위해 정규화된 데이터를 일부 통합하는 과정입니다. 예를 들어, 자주 조회되는 데이터를 조인 없이 조회할 수 있도록 한 테이블에 중복 저장하는 경우가 있습니다.

### 4. 함수 종속성

함수 종속성은 특정 컬럼이 다른 컬럼에 의해 결정되는 관계를 의미합니다. 예를 들어, 학생 테이블에서 학번이 주어지면 학생의 이름이 결정되는 경우, 학번 → 이름의 함수 종속성이 존재합니다. 이는 정규화를 진행할 때 중요한 개념이며, 잘못된 함수 종속 관계를 제거하는 것이 정규화의 핵심입니다.

### 5. JOIN의 종류와 활용 예시

INNER JOIN은 두 테이블에서 공통된 키 값을 가진 행만 반환합니다. 일반적으로 가장 많이 사용되는 JOIN 방식으로, 데이터의 무결성을 유지하며 필요 없는 데이터를 제거하는 데 유용합니다.

```sql
SELECT C.customer_id, [C.name](http://c.name/), O.order_id, O.amount
FROM Customer C
INNER JOIN Orders O
ON C.customer_id = O.customer_id;
```

LEFT/RIGHT JOIN은 왼쪽/오른쪽 테이블의 모든 행을 유지하면서, 오른쪽/왼쪽 테이블에서 일치하는 값이 있으면 가져오고, 없으면 NULL을 반환합니다. 한쪽 테이블의 모든 데이터를 보존해야 할 때 유용합니다.

```sql
SELECT C.customer_id, [C.name](http://c.name/), O.order_id, O.amount
FROM Customer C
LEFT JOIN Orders O
ON C.customer_id = O.customer_id;
```

FULL JOIN은 LEFT JOIN + RIGHT JOIN의 조합으로, 두 테이블의 모든 데이터를 포함하며, 일치하는 경우 결합하고, 일치하지 않는 경우 NULL을 포함합니다. 일부 데이터베이스(MySQL 등)에서는 FULL JOIN을 직접 지원하지 않으며, `LEFT JOIN`과 `RIGHT JOIN`을 `UNION`으로 결합하여 구현합니다.

```sql
SELECT C.customer_id, [C.name](http://c.name/), O.order_id, O.amount
FROM Customer C
FULL JOIN Orders O
ON C.customer_id = O.customer_id;
```

CROSS JOIN (카테시안 곱)은 두 테이블의 **모든 행을 조합**하여 가능한 모든 조합을 생성합니다. 조인 조건이 없으며, 모든 행이 서로 곱해지는 방식으로 동작하여 행 개수가 급격히 증가할 수 있습니다.

```sql
SELECT C.customer_id, C.name, P.product_id, P.product_name
FROM Customer C
CROSS JOIN Product P;
```

SELF JOIN은 동일한 테이블을 서로 다른 별칭으로 사용하여 JOIN을 수행하는 방식입니다. 계층 구조 데이터를 조회하거나, 같은 테이블 내에서 특정 조건을 비교할 때 사용됩니다.

```sql
SELECT E1.employee_id, E1.name AS EmployeeName, E2.name AS ManagerName
FROM Employee E1
LEFT JOIN Employee E2
ON E1.manager_id = E2.employee_id;
```

### 6. JOIN 사용 시 주의해야 할 점

JOIN을 사용할 때는 조인 조건이 없으면 CROSS JOIN처럼 불필요한 데이터 폭증이 발생할 수 있어 주의해야 하며, 인덱스를 적절히 활용하지 않으면 성능 저하가 발생할 수 있습니다. 또한 JOIN 순서에 따라 실행 계획이 달라질 수 있어 최적화가 필요하며, OUTER JOIN 사용 시 NULL 값을 고려한 데이터 처리가 필요합니다.

### 7. Materialized View

일반 View와 달리 실제 데이터가 저장되는 뷰입니다. 일반 뷰는 조회할 때마다 원본 테이블의 데이터를 참조하지만, Materialized View는 생성 시점의 결과를 물리적으로 저장하여 성능을 향상시킵니다.

Materialized View의 주요 특징은 데이터를 미리 저장하여 조회 성능을 높일 수 있지만, 최신 데이터와의 동기화가 필요하다는 점입니다. 정기적인 REFRESH를 통해 원본 테이블의 변경 사항을 반영할 수 있으며, 자동 갱신(AUTOMATIC REFRESH)과 수동 갱신(MANUAL REFRESH) 방식이 존재합니다.

Materialized View는 대량의 데이터 처리와 복잡한 연산이 필요한 경우 유용하며, 분석 시스템이나 데이터 웨어하우스에서 자주 사용됩니다. 하지만 원본 데이터가 변경될 때마다 동기화 비용이 발생할 수 있으므로, 갱신 주기를 신중히 설정해야 합니다.

### 8. Union 사용 시 성능 저하 케이스

UNION 사용 시 성능 저하가 발생하는 주요 원인은 중복 제거 과정(SORT 연산) 때문입니다. UNION은 기본적으로 결과 집합에서 중복된 데이터를 제거하는데, 이 과정에서 정렬(SORT) 연산이 수행되며, 데이터가 많을수록 성능이 저하될 수 있습니다.

반면, UNION ALL은 중복 제거 없이 단순히 데이터를 합치므로 정렬 비용이 발생하지 않아 성능이 더 우수합니다. 따라서, 중복 데이터가 문제가 되지 않는 경우 UNION 대신 UNION ALL을 사용하는 것이 성능 최적화에 유리합니다.

특히, 대량의 데이터가 포함된 쿼리에서 UNION을 사용할 경우 인덱스를 적절히 활용하지 않으면 전체 테이블 스캔이 발생할 수 있으며, 이로 인해 쿼리 실행 시간이 급격히 증가할 수 있습니다. 따라서, 불필요한 UNION 사용을 지양하고, 필요할 경우 중복 제거 로직을 애플리케이션 레벨에서 처리하는 것도 고려할 수 있습니다.

### 9. ERD(엔터티, 속성, 관계)

엔터니는 데이터의 주요 객체로 “학생 테이블”입니다. 속성은 엔터티가 가지는 특성으로 “학생 이름”, “학번” 등이 있습니다. 관계는 엔터티 간의 연관성으로, “학생은 수강 신청을 한다.”가 있습니다.

### 10. ERD 관계 유형

ERD에서 관계 유형은 일대일(1:1), 일대다(1:N), 다대다(N:M) 세 가지가 있습니다.

- 1:1 관계: 한 엔터티의 한 개 레코드가 다른 엔터티의 한 개 레코드와만 연결됨. (예: 사용자와 주민등록정보)
- 1:N 관계: 한 엔터티의 한 개 레코드가 다른 엔터티의 여러 레코드와 연결됨. (예: 고객과 주문)
- N:M 관계: 여러 개의 레코드가 서로 다수와 연결됨. (예: 학생과 강의) → 중간 테이블(연결 테이블)을 사용해 1:N, N:1로 분해해야 함.

### 11. 관계형 데이터 베이스의 핵심 특징을 설명해주세요.

관계형 데이터베이스의 핵심 특징은 정규화, ACID 특성, 스키마 기반 구조, SQL 지원, 그리고 관계 모델 사용입니다. 관계형 데이터베이스는 데이터를 중복 없이 체계적으로 관리하기 위해 정규화를 적용하며, 이를 통해 데이터의 무결성과 일관성을 유지합니다. 또한, 트랜잭션의 안정성을 보장하기 위해 원자성, 일관성, 격리성, 지속성을 의미하는 ACID 특성을 따릅니다. 스키마 기반 구조를 통해 테이블과 컬럼의 데이터 타입을 명확하게 정의하고, 이를 바탕으로 SQL을 사용하여 데이터를 조작할 수 있습니다. 마지막으로, 기본 키와 외래 키를 활용한 관계 모델을 기반으로 데이터를 연결하여 테이블 간의 정합성을 유지하며, 이를 통해 데이터의 일관성을 보장할 수 있습니다.

### 12. 복합키 사용하는 상황을 예시로 들어 설명해주세요.

복합키는 두 개 이상의 컬럼을 결합하여 하나의 기본 키로 설정할 때 사용됩니다. 일반적으로 개별 컬럼만으로는 고유성을 보장할 수 없을 때 활용됩니다. 예를 들어, 대학의 수강 신청 테이블에서 학생과 과목의 관계를 나타내는 경우, 하나의 학생이 여러 과목을 신청할 수 있고, 하나의 과목에는 여러 학생이 등록될 수 있습니다. 이때, 학생 ID와 과목 ID를 복합키로 설정하면 같은 학생이 같은 과목을 중복 신청하는 것을 방지할 수 있습니다. 또한, 물류 관리 시스템에서 창고별로 상품을 관리하는 테이블을 설계할 때, 상품 ID만으로는 같은 상품이 여러 창고에 보관될 수 있어 고유성이 보장되지 않으므로, 창고 ID와 상품 ID를 복합키로 설정하면 각 창고에서 특정 상품을 구별할 수 있습니다.

### 13. INNER JOIN과 LEFT JOIN의 차이를 예시로 설명해주세요.

INNER JOIN과 LEFT JOIN의 차이는 조인 시 포함되는 데이터의 범위에서 나타납니다. INNER JOIN은 두 테이블에서 조인 조건이 일치하는 데이터만 반환하는 반면, LEFT JOIN은 왼쪽 테이블의 모든 데이터를 유지하면서 오른쪽 테이블에서 일치하는 데이터가 있으면 가져오고, 없으면 NULL로 표시합니다. 예를 들어, 고객 테이블과 주문 테이블이 있다고 가정했을 때, INNER JOIN을 사용하면 주문이 있는 고객만 조회되므로 주문 내역이 없는 고객은 결과에서 제외됩니다. 반면, LEFT JOIN을 사용하면 모든 고객이 조회되며, 주문이 없는 고객의 경우 주문 정보가 NULL로 표시됩니다. 즉, INNER JOIN은 두 테이블의 교집합을 반환하는 방식이고, LEFT JOIN은 왼쪽 테이블의 데이터를 우선 유지하면서 오른쪽 테이블의 데이터를 결합하는 방식이라는 차이가 있습니다.

### 14. Materialized View와 일반 뷰의 차이점에 대해서 설명해주세요.

Materialized View와 일반 뷰의 차이점은 데이터 저장 방식과 성능 최적화에 있습니다. 일반 뷰는 기본 테이블의 데이터를 실시간으로 조회하는 가상의 테이블로, 쿼리를 실행할 때마다 원본 테이블에서 데이터를 가져오므로 최신 상태를 유지할 수 있지만 조회 성능이 저하될 수 있습니다. 반면, Materialized View는 쿼리 결과를 물리적으로 저장하여 조회 속도를 향상시키지만, 원본 데이터가 변경될 경우 자동으로 반영되지 않으며 갱신(Refresh) 작업이 필요합니다. 따라서, 자주 변경되는 데이터는 일반 뷰가 적합하며, 복잡한 연산이나 대량의 데이터 조회가 빈번한 경우에는 Materialized View를 활용하여 성능을 최적화할 수 있습니다.

### 15. (특정 상황 제시 후) VARCHAR와 CHAR 중 어떤것을 선택해야하나요?

VARCHAR와 CHAR 중 어떤 것을 선택할지는 데이터의 특성과 용도에 따라 달라집니다. 만약 저장할 데이터의 길이가 가변적이고 불필요한 공간 낭비를 줄이는 것이 중요하다면 VARCHAR을 선택하는 것이 적절합니다. 예를 들어, 고객의 이메일 주소처럼 길이가 일정하지 않은 데이터를 저장할 경우 VARCHAR을 사용하면 저장 공간을 효율적으로 활용할 수 있습니다. 반면, 데이터 길이가 항상 일정하고 빠른 검색 속도가 중요한 경우에는 CHAR을 선택하는 것이 유리합니다. 예를 들어, 국가 코드나 주민등록번호처럼 항상 고정된 길이를 가지는 데이터를 저장할 때 CHAR을 사용하면 조회 성능이 향상될 수 있습니다. 따라서, 데이터 길이가 일정하면 CHAR을, 가변적이면 VARCHAR을 사용하는 것이 적절한 선택입니다.

### 16. DATETIME과 TIMESTAMP의 차이점에 대해서 설명해주세요.

DATETIME과 TIMESTAMP의 차이는 저장 방식과 시간대(Time Zone) 적용 여부에 있습니다. DATETIME은 ‘YYYY-MM-DD HH:MI:SS’ 형식으로 저장되며, 시간대의 영향을 받지 않고 그대로 유지됩니다. 반면, TIMESTAMP는 UNIX 타임스탬프 형식으로 저장되며, 데이터베이스의 시간대 설정에 따라 변환될 수 있습니다. 또한, TIMESTAMP는 DATETIME보다 저장 공간을 적게 차지하며, 자동으로 현재 시간을 저장하는 기능을 지원할 수 있어 로그 기록이나 데이터 변경 이력 관리에 유용합니다. 하지만 TIMESTAMP는 저장할 수 있는 범위가 1970년부터 2038년까지로 제한되어 있어, 이보다 넓은 기간의 날짜를 다룰 경우 DATETIME을 사용하는 것이 적절합니다.

### 17. GROUP BY와 HAVING의 차이점을 설명해주세요.

GROUP BY와 HAVING의 차이는 데이터 그룹화와 그룹에 대한 조건 적용 여부에서 나타납니다. GROUP BY는 특정 컬럼을 기준으로 데이터를 그룹화하는 데 사용되며, 각 그룹에 대해 집계 함수(SUM, AVG 등)를 적용할 수 있습니다. 반면, HAVING은 GROUP BY로 그룹화된 데이터에 대한 조건을 필터링하는 역할을 합니다. 즉, WHERE 절이 개별 행에 대한 조건을 적용하는 반면, HAVING은 그룹화된 결과에 대한 조건을 적용한다는 차이가 있습니다. 예를 들어, 부서별 평균 급여를 계산한 후, 평균 급여가 500만 원 이상인 부서만 조회하려면 GROUP BY를 사용하여 부서별로 데이터를 묶고, HAVING을 사용하여 특정 조건을 만족하는 그룹만 필터링해야 합니다.