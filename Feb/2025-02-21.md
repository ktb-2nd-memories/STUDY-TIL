# TIL

## 날짜: 2025-02-21

### 스크럼
- 학습 목표 1 : 4주차 내용 딥다이브

### 새로 배운 내용

### 6. 렉시컬 스코프의 결정 원리와 호이스팅이 코드 실행에 미치는 영향을 설명해주세요.

1. **스코프란?**
    - 변수, 함수, 객체에 접근할 수 있는 범위를 결정하는 규칙
    - 자바스크립트에서는 함수 단위의 스코프와 블록 단위의 스코프가 존재함.
    - 전역 스코프, 지역 스코프, 블록 스코프 (`let` , `const`)
        - 전역 스코프: 코드 어디서든 접근할 수 있는 변수와 함수가 속하는 영역
        - 지역 스코프: 함수 내부에서 선언된 변수는 해당 함수 내에서만 접근 가능하며, 바깥에서는 접근할 수 없음
        - 블록 스코프: `let` 과 `const` 는 블록( {} ) 단위로 유효 범위를 가짐. 반면, `var` 는 함수 단위 스코프를 가지므로 블록을 무시함.

      | **키워드** | **블록 스코프** | **함수 스코프** | **재선언 가능 여부** | **TDZ(Temporal Dead Zone)** |
            | --- | --- | --- | --- | --- |
      | **`var`**  | X (블록 무시) | O (함수 내부에서만 유효) | O (같은 스코프 내에서 가능) | X |
      | **`let`**  | O (블록 내부에서만 유효) | X | X (같은 스코프 내에서 재선언 불가능) | O (선언 전에 접근하면 `ReferenceError` ) |
      | **`const`** | O (블록 내부에서만 유효) | X | X (같은 스코프 내에서 재선언 불가능) | O (선언 전에 접근하면 `ReferenceError` ) |

1. **렉시컬 스코프의 결정 원리**
    - 렉시컬 스코프란 **함수가 정의된 위치(정적 위치)에 따라 변수의 유효 범위(Scope)가 결정되는 방식**
    - 자바스크립트는 렉시컬 스코프(Lexical Scope, 정적 스코프)를 따름
    - 즉, **함수가 호출되는 위치가 아니라, 선언된 위치를 기준으로 스코프를 결정함.**
    - 코드로 살펴봅시다. ⇒

    ```java
    const a = "Global";
    
    function outer() {
      const a = "Outer";
      
      function inner() {
        console.log(a); // "Outer" 출력
      }
      
      inner();
    }
    
    outer();
    ```

    - `inner` 함수 내부에서 `a` 를 참조할 때, 실행되는 위치가 아니라 함수가 선언된 위치를 기준으로 스코프를 결정함.
    - `inner` 함수는 `outer` 함수 내부에서 선언되었기 때문에, `inner` 함수 내부에서 `a` 를 찾을 때 `outer` 의 `a = "Outer"` 를 참조함.
    - `outer` 함수 내부에 `a` 가 없었다면, 전역 변수 `a = "Global"` 을 참조하게 됨.

2. **스코프 체인(Scope Chain)**
    - 렉시컬 스코프를 기반으로 자바스크립트 엔진은 스코프 체인을 따라 변수를 검색함.
    - 스코프 체인 탐색 과정을 코드로 살펴봅시다. ⇒

    ```java
    const globalVar = "Global";
    
    function outer() {
      const outerVar = "Outer";
    
      function inner() {
        const innerVar = "Inner";
        console.log(globalVar); // "Global"
        console.log(outerVar); // "Outer"
        console.log(innerVar); // "Inner"
      }
    
      inner();
    }
    
    outer();
    ```

    - `inner()` 내부에서 변수를 찾을 때, **스코프 체인을 따라 하나씩 검색**
    - **순서**: `inner()` → `outer()` → 전역 스코프(Global Scope)
    - 변수 `innerVar`는 `inner()` 내부에서 찾고, `outerVar`는 `outer()`에서 찾고, `globalVar`는 전역에서 찾음.

   > **즉, 변수를 찾을 때 실행 시점이 아니라, 렉시컬 환경(Lexical Environment)에서 정의된 스코프 체인을 따라간다.
   ⇒ 코드를 예측 가능하게 유지하고, 실행 위치에 따라 값이 바뀌는 혼란을 방지함.**

3. **호이스팅 (Hoisting)**
    - 자바스크립트 엔진이 실행 전에 변수와 함수 선언을 **코드의 최상단으로 끌어올리는 것처럼 동작하는 현상**
    1. **변수 `var` 호이스팅**
        - 작성한 코드

        ```jsx
        console.log(a); // undefined
        var a = 10;
        console.log(a); // 10
        ```

        - 실제 실행 과정

        ```jsx
        var a; // (1) 선언이 먼저 호이스팅됨
        console.log(a); // (2) undefined (초기화되지 않음)
        a = 10; // (3) 값 할당
        console.log(a); // (4) 10
        ```

        - `var`는 선언만 **호이스팅**되고, **할당은 호이스팅되지 않음.** 따라서 `console.log(a)`에서 `undefined`가 출력됨.
        - `var` 는 호이스팅되면서 자동으로 `undefined` 로 초기화되므로, 선언 전에 접근할 때도 오류 없이 실행되지만, 의도한 값이 아닐 수 있어 버그의 원인이 됨.

    1. **`let` 과 `const` 의 호이스팅 (TDZ, Temporal Dead Zone)**

        ```jsx
        console.log(b); // ReferenceError: Cannot access 'b' before initialization
        let b = 20;
        ```

        - `let`과 `const`도 **선언이 호이스팅되지만, 초기화되지 않기 때문에,**   TDZ(Temporal Dead Zone)에 의해 **선언 전에 접근하면 오류를 발생시킴.**
        - TDZ 덕분에 변수를 선언 전에 접근하면 오류가 발생하므로, 실수로 선언 전에 사용하는 버그를 방지할 수 있음.
        - 즉, 명확한 실행 흐름을 유지할 수 있어 코드의 가독성과 예측 가능성이 높아짐. (개발자의 실수를 줄이고 안전한 코드 작성을 유도하는 것)

4. **함수 호이스팅**
    1. **함수 선언문(Function Declaration)**
    - 작성한 코드

      ```jsx
      sayHello(); // "Hello, world!"
     
      function sayHello() {
        console.log("Hello, world!");
      }
      ```

        - 함수 선언문은 선언과 정의(함수 본문)가 함께 호이스팅되므로, 호출 전에 사용 가능
        - 즉, 함수의 코드가 어디에 위치하든, 해당 함수는 스크립트가 실행되기 전에 메모리에 먼저 등록되므로 호출 전에 사용 가능함.

    - **실제 실행 과정**

      ```jsx
      // (1) 함수 선언문이 먼저 메모리에 저장됨
      function hello() {
        console.log("Hello!");
      }
     
      // (2) 함수 호출
      hello(); // "Hello!"
      ```

        1. **컴파일 단계**
            - 함수 선언문을 메모리에 먼저 저장하므로 코드의 어디에서든 호출이 가능해짐
        2. **실행 단계**
            - 함수가 실제로 호출되면 저장된 함수 정의를 실행

   >    **즉, 함수 선언문은 “정의된 위치”와 관계없이 코드 어디서든 사용할 수 있도록 미리 등록됨**

    2. **함수 표현식 (Function Declaration)**
    - 작성한 코드

   ```javascript
    console.log(greet); // undefined
    greet(); // ❌ TypeError: greet is not a function
        
    var greet = function () {
    console.log("Good morning!");
    };
        
    greet(); // "Good morning!"
    ```

    - 실제 실행 과정

   ```javascript
    var greet; // (1) 변수 선언만 호이스팅됨 (초기화되지 않음, 값은 undefined)
    
    console.log(greet); // (2) undefined 출력 (변수는 선언되었지만, 초기화되지 않음)
    
    greet(); // (3) undefined(); -> TypeError 발생 (undefined는 함수가 아님)
    
    greet = function () {  // (4) 실행 단계에서 함수 할당
        console.log("Good morning!");
    };
    
    greet(); // (5) 함수 실행 -> "Good morning!" 출력
    ```

    1. **컴파일 단계 (Execution Context 생성 시)**
        1.  `var greet;` 변수 선언이 **호이스팅**됨 (값은 `undefined`, 함수 자체는 메모리에 등록되지 않음).
        2. 함수 표현식의 오른쪽 부분(`function() {...}`)은 **초기화되지 않음**.

       > 이 시점에서 `greet`은 **undefined 상태**이다.

    2. **실행 단계 (Runtime)**
        1. `console.log(greet);` 실행 → `undefined` 출력 (변수는 선언되었지만, 초기화되지 않았기 때문)
        2. `greet();` 실행 → `undefined();`이므로 **TypeError 발생** (`undefined`는 함수가 아님)
        3. `greet = function () { console.log("Good morning!"); }` 실행 → 이제 `greet`이 함수로 초기화됨.
        4. `greet();` 실행 → `"Good morning!"` 출력

1. **호이스팅이 코드 실행에 미치는 영향**
    - **var 변수의 경우 undefined 반환**
        - `var`는 선언이 호이스팅되고, 초기화는 실행 시점에서 이루어지므로 `undefined` 발생
    - **let, const의 경우 TDZ(Temporal Dead Zone) 발생**
        - `let`, `const`는 초기화 전에 접근하면 **ReferenceError 발생**
    - **함수 선언문은 호이스팅되어 호출 전에 사용 가능**
        - 함수 선언문은 선언과 정의가 함께 호이스팅되므로 정상 동작
    - **함수 표현식은 변수 호이스팅을 따르므로 undefined 오류 발생 가능**
        - 함수 표현식은 `var`를 사용하면 `undefined`, `let/const`를 사용하면 TDZ 오류 발생

1. **결론: 올바른 코드 작성 방법**
    - **변수는 항상 코드 상단에서 선언하기**
    - **let, const를 사용하여 TDZ를 방지하고 가독성을 높이기**
    - **함수 표현식을 활용하여 명확한 실행 순서를 유지하기**
    - **var 대신 let, const 사용하기**

> **렉시컬 스코프와 호이스팅을 정확히 이해하면, 코드의 실행 흐름을 예측하고 오류를 방지할 수 있다.**
>

---

### Kevin의 딥다이브 질문

- **렉시컬 스코프와 동적 스코프를 비교해보세요.**
    - 정적 스코프는 함수가 선언된 위치를 기준으로 스코프가 결정됩니다. 코드를 작성할 때 스코프가 결정되며, 코드 실행 위치와 무관하게 변수를 찾습니다. 그래서 예측 가능하고 이해하기 쉬운 코드를 작성할 수 있습니다. 또, 컴파일 단계에서 스코프 결정이 가능하므로 최적화하기가 용이합니다. 단점으로는 다른 스코프의 변수를 사용하고자 할 때 클로저와 같은 추가적인 메커니즘이 필요할 수 있습니다.
    - 동적 스코프는 함수가 어디서 호출되었는지를 기준으로 스코프가 결정됩니다. 함수가 실행되는 환경에 따라 변수를 찾습니다. 일부 특정 상황에서 호출 컨텍스트(Call Stack)에 따라 다른 동작을 하는 함수를 만들 때 유용합니다. 하지만, 코드의 흐름을 따라가기 어려워 디버깅이 복잡하고 가독성이 낮아 유지보수가 어렵습니다. 또한, 컴파일 타임에 스코프를 결정할 수 없어 최적화가 어려워지고 성능 저하로 이어질 수 있습니다.

- **호이스팅에서 발생할 수 있는 문제점을 말해보세요.**
    - `var` 로 선언된 변수가 호이스팅되면, 코드에서 변수가 선언된 위치와 관계없이 최상단에서 선언된 것처럼 동작합니다. 이로 인해 예상치 못한 undefined 값이 발생하거나, 의도와 다른 동작이 나타날 수 있습니다. 또, `var` 로 선언된 변수는 같은 스코프 내에서 여러 번 재선언할 수 있습니다. 이는 코드의 예측 가능성을 떨어뜨리고, 실수로 변수 값을 덮어쓰는 문제를 일으킬 수 있습니다. 또, `var` 는 블록 스코프를 무시하고 함수 스코프만을 따르기 때문에, `if` `for` `while` 등의 블록 내에서 선언된 변수가 블록 외부에서 접근 가능하게 됩니다. 이로 인해 스코프에 대한 혼동이 발생할 수 있습니다. 또, 함수 표현식은 변수에 할당된 상태로 작성될 수 있어서 이 경우 호이스팅은 변수를 undefined로 만들어 함수 호출 전에 예기치 못한 TypeError가 발생할 수 있습니다.