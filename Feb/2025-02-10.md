# TIL

## 날짜: 2025-02-10

### 스크럼
- 학습 목표 1 : 임계영역, 공유 자원, 동기화, 락

### 새로 배운 내용

| **구분** | **정의** | **비고** |
| --- | --- | --- |
| **공유 자원** | 여러 프로세스나 스레드가 동시에 접근할 수 있는 자원. | 파일, 데이터베이스, 메모리 등이 있음. |
| **임계 영역** | 여러 스레드가 동시에 접근하면 문제가 발생할 수 있는 공유 자원에 대한 코드 블록. | 상호 배제를 통해 동기화가 필요함. |
| **동기화** | 여러 스레드나 프로세스가 공유 자원에 대해 일관된 상태를 유지하도록 실행 순서를 조정하는 방법. | Java에서는 `synchronized` , `ReentrantLock` 등이 사용됨. |
| **락** | 공유 자원에 대한 동시 접근을 제어하기 위한 메커니즘. | Java의 `Lock` 인터페이스, Oracle의 `ROW LOCK` 등이 있음. |
| **원자성** | 작업이 중간에 중단되지 않고 전체가 실행되거나 전혀 실행되지 않는 성질. | 트랜잭션의 ACID 속성 중 하나. |
| **상호 배제 (Mutual Exclusion)** | 두 개 이상의 프로세스가 동시에 동일한 자원에 접근하지 못하도록 보장하는 개념. | `Mutex` , `Semaphore` 등이 상호 배제를 지원. |
| **진행 (Progress)** | 임계 영역에 진입한 프로세스를 결정하는 과정에서 불필요한 대기가 없어야 하는 성질. | 락을 획득할 수 있는 스레드가 반드시 실행 가능해야 함. |
| **유한한 대기 (Bounded Waiting)** | 특정 프로세스가 임계 영역에 들어가기 위해 무한적 기다리지 않도록 보장하는 성질. | Starvation(기아 현상)을 방지하는 기법. |
| **데드락** | 둘 이상의 프로세스가 서로 자원의 해제를 기다리면서 영원히 블록킹되는 현상. | 교착 상태 방지를 위해 락 순서 관리 필요. |
| **Race Condition** | 두 개 이상의 스레드가 동시에 공유 자원에 접근할 때 실행 순서에 따라 결과가 달라지는 문제. | `volatile` , `synchronized` 로 해결 가능. |
| **기아 현상** | 하나 이상의 프로세스가 지속적으로 자원을 할당받지 못하는 상황. | 우선순위 기반 스케줄링에서 발생 가능. |
| **락-프리 (Lcok-Free) / 웨이트-프리 (Wait-Free)** | 락을 사용하지 않고 동기화를 달성하는 방식. | `AtomicInteger` , `CAS (Comare-And-Swap)` 기법 사용. |
| **알고리즘** | 특정 문제를 해결하기 위한 명확한 절차나 로직의 집합. | 동기화 알고리즘, 병렬 처리 알고리즘 등이 있음. |
| **스핀락** | 락을 획득할 때까지 계속 루프를 돌며 대기하는 방식. | `while` 루프로 CPU를 소비하며 대기. |
| **낙관적 락** | 충돌이 적을 것이라 가정하고 먼저 진행한 후 충돌이 발생하면 롤백하는 방식. | 데이터베이스에서 `MVCC` 와 함께 사용됨. |
| **뮤텍스** | 한 번에 하나의 스레드만 자원에 접근할 수 있도록 보장하는 동기화 객체. | `Mutex` 와 `Semaphore` 의 차이는 `Mutex` 는 소유 개념이 있음. |
| **조건 변수 (Condition Variable)** | 특정 조건을 만족할 때까지 스레드를 대기하도록 하는 동기화 기법. | `wait()` , `notify()` 메서드 활용. |
| **Read-Write Lock** | 읽기 작업은 여러 개 허용하지만 쓰기 작업은 단독으로 실행되도록 하는 락. | `ReadWriteLock` 인터페이스 사용 (Java). |
| **세마포어** | 카운터 값을 사용하여 여러 개의 프로세스가 자원을 공유하도록 관리하는 동기화 기법. | `Semaphore` 객체를 통해 구현 (Java). |
| **분산 락** | 분산 환경에서 여러 노드가 동일한 자원에 접근할 때 사용하는 락. | Redis, Zookeeper 기반의 분산 락 사용. |

<br>

### 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.

공유 자원은 여러 프로세스나 스레드가 동시에 접근할 수 있는 자원을 의미합니다. 대표적인 예로 파일, 데이터베이스, 메모리, 네트워크 소켓 등이 있습니다.

**왜 사용하는가?**

공유 자원을 사용하는 이유는 **효율적인 자원 활용과 협업**입니다.

- **메모리 절약**: 프로세스마다 개별적으로 자원을 할당하면 낭비가 심함 → 공유하여 최적화
- **데이터 일관성 유지**: 여러 사용자나 프로세스가 같은 데이터에 접근할 필요가 있음 → 데이터베이스 공유
- **프로세스 간 협업**: 운영체제의 IPC(Inter-Process Communication)에서 공유 메모리를 활용해 효율적으로 통신

**실행활/개발 예시**

- **은행 시스템**: 여러 사용자가 동시에 계좌를 조회하고 입출금할 때, 동일한 데이터베이스 자원을 공유해야 함.
- **웹 서버의 Connection Pool**: DB 연결을 효율적으로 관리하기 위해 일정 수의 커넥션을 공유하여 사용함.

<br>

### 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?

**정의**

임계 영역(Critical Section)은 **동시에 실행되면 충돌이 발생할 수 있는 코드 영역**으로, 보통 공유 자원에 대한 접근이 이루어지는 부분.

**중요성**

- 여러 스레드가 동시에 접근하면 데이터 무결성이 깨질 수 있음
- 경쟁 조건(Race Condition) 발생 가능
- 데이터 오염, 불일치 발생

**보호하지 않았을 때 발생할 수 있는 문제**

- **Race Condition**: 두 개 이상의 스레드가 동시에 실행되며 예상치 못한 결과가 발생함.
- **데이터 불일치(Inconsistency)**: 예를 들어, 계좌 이체 중 하나의 스레드가 출금, 다른 스레드가 잔액 조회를 하면 충돌 발생.
- **데드락(Deadlock) 가능성**: 임계 영역 접근 순서를 보장하지 않으면 데드락 발생.

<br>

### 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.

**정의**

동기화는 **여러 스레드가 공유 자원에 접근할 때 실행 순서를 조정하여 데이터의 일관성과 무결성을 보장하는 기법.** 멀티스레드 환경에서는 여러 스레드가 동시에 같은 데이터를 읽고 쓸 수 있기 때문에 동기화가 필수적임. 동기화가 없으면 데이터 불일치나 손상과 같은 문제가 발생할 수 있음.

동기화가 없으면 발생할 수 있는 문제

1. **Race Condition (경쟁 조건)**
    - 두 개 이상의 스레드가 공유 자원에 동시에 접근하여 예기치 않은 결과가 발생하는 문제.

    ```java
    class BankAccount {
        private int balance = 100;
    
        public void withdraw(int amount) {
            if (balance >= amount) { // 잔액 체크
                balance -= amount;   // 출금
            }
        }
    }
    ```

    - **문제**
        - 두 개의 스레드가 동시에 `withdraw(50)`을 호출하면, 두 개의 스레드가 모두 `if (balance >= amount)`를 통과하지만, 최종 잔액이 50이 아닌 **0이 될 수도 있음.**
        - 이유: `balance -= amount;` 연산이 동시에 실행될 경우 올바른 값이 저장되지 않음.
    - **해결 방법**: `synchronized` 또는 `Lock` 사용

    ```java
    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount;
        }
    }
    ```


2. **Dirty Read (더티 리드)**
    - 한 트랜잭션이 데이터를 수정하는 중에, 다른 트랜잭션이 수정 중인 데이터를 읽으면 **잘못된 값이 반영될 수 있음.** (예: 아직 커밋되지 않은 변경 사항을 읽는 경우)

    ```sql
    BEGIN TRANSACTION;
    UPDATE accounts SET balance = 200 WHERE id = 1;
    -- 아직 COMMIT 하지 않음
    
    -- 다른 프로세스에서 balance 조회 가능 (잘못된 값)
    SELECT balance FROM accounts WHERE id = 1;
    ```

    - **문제**
        - 첫 번째 트랜잭션이 **ROLLBACK** 하면 데이터는 변경되지 않았어야 하지만, 다른 트랜잭션이 더티 데이터를 읽었기 때문에 잘못된 결과가 발생할 수 있음.
    - **해결 방법**: 트랜잭션 격리 수준을 `READ COMMITTED` 이상으로 설정.

    ```sql
    SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
    ```


3. **Lost Update (손실된 업데이트)**
    - 여러 스레드가 동시에 같은 데이터를 업데이트하면서 변경 사항이 덮어씌워지는 문제.

    ```sql
    -- Thread 1
    SELECT balance FROM accounts WHERE id = 1; -- balance = 100
    UPDATE accounts SET balance = 100 - 10 WHERE id = 1;
    
    -- Thread 2
    SELECT balance FROM accounts WHERE id = 1; -- balance = 100
    UPDATE accounts SET balance = 100 - 20 WHERE id = 1;
    ```

    - **문제**
        - 두 개의 트랜잭션이 동일한 값(100)을 읽고 수정하므로, **결과적으로 하나의 업데이트가 손실됨**.
        - 만약 Thread 1과 Thread 2가 같은 시점에 실행되면, 최종 잔액은 90이 아니라 80이어야 하지만 **잘못된 값이 저장될 수 있음.**
    - **해결 방법**: `Pessimistic Lock (비관적 락)` 또는 `Optimistic Lock (낙관적 락)` 사용

    ```sql
    -- Pessimistic Lock 사용
    SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
    ```

<br>

### 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.

락은 동시에 여러 개의 스레드가 공유 자원에 접근하지 못하도록 하여 데이터 무결성을 보장하는 동기화 메커니즘. 이를 통해 원자성을 유지하고, 경쟁 조건을 방지할 수 있음.

**락의 동작 방식**

| **종류** | **설명** | **동작 방식** |
| --- | --- | --- |
| **비관적 락 (Pessimistic Lock)** | 충돌이 발생할 가능성이 높다고 가정하고, 공유 자원에 대한 접근을 차단하는 방식 | 데이터를 수정하는 동안 **다른 트랜잭션의 접근을 차단**하여 동시 실행을 방지함. 데이터베이스에서는 `SELECT ... FOR UPDATE` 와 같은 명령어로 구현 가능 |
| **낙관적 락 (Optimistic Lock)** | 충돌이 적을 것이라고 가정하고, 데이터를 갱신할 때만 충돌을 감지하는 방식 | 데이터를 읽을 때는 잠금을 하지 않지만, 업데이트 시점에 데이터가 변경되지 않았는지 **버전 번호나 해시 값 비교**를 통해 충돌을 확인하고, 충돌이 발생하면 롤백  |
| **뮤텍스 (Mutex)** | 한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 보장하는 방식 | `synchronized` 키워드를 사용하여 하나의 스레드가 락을 획득하면 다른 스레드는 대기 |
| **스핀락 (Spin Lock)** | 락이 해제될 때까지 계속해서 CPU를 사용하여 확인하는 방식 | `while` 루프를 사용하여 **락을 획득할 수 있을 때까지 기다리지만, CPU 리소스를 소모** |
| Read-Write Lock | 읽기 작업은 여러 개 허용하지만, 쓰기 작업은 단독 실행하는 방식 | `ReadWriteLock` 을 사용하여 **읽기 연산을 병렬 실행하되, 쓰기 연산은 단독 실행** |
| 세마포어 (Semaphore) | 일정 개수의 스레드만 공유 자원에 접근할 수 있도록 제한하는 방식 | `Semaphore`  클래스를 사용하여 **N개의 스레드만 접근 가능하도록 제한** |
| 분산 락 (Distributed Lock) | 여러 서버에서 동시에 공유 자원에 접근할 때 충돌을 방지하는 방식 | **Redis, Zookeeper**와 같은 외부 시스템을 활용하여 다중 서버 간의 동시 접근 제어 |

**락이 없으면 발생하는 문제**

| 문제 유형 | 설명 | 해결 방법 |
| --- | --- | --- |
| Race Condition | 두 개 이상의 스레드가 동일한 자원에 접근하여 예상치 못한 결과 발생 | `synchronized` , `Lock` 을 활용하여 임계 영역 보호 |
| Dirty Read | 한 트랜잭션이 변경한 데이터를 다른 트랜잭션이 읽으면 잘못된 값 참조 | 트랜잭션 격리 수준을 `READ COMMITTED` 이상으로 설정 |
| Lost Update | 여러 스레드가 동시에 업데이트하면 한 스레드의 변경 사항이 사라짐 | 비관적 락(`FOR UPDATE` ) 또는 낙관적 락(Versioning) 활용 |
| Deadlock | 서로 다른 프로세스가 상대방의 락이 풀리길 기다리면서 영원히 멈춤 | 락 순서를 정하고, 타임아웃을 설정하여 해결 |
| Starvation | 우선순위가 낮은 프로세스가 락을 계속 획득하지 못함 | 공정한 락 정책(FIFO Lock) 사용 |

<br>

### 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.

| 구분 | 뮤텍스 | 세마포어 |
| --- | --- | --- |
| 동작 방식 | 한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 보장 | 카운터 값을 사용하여 여러 개의 스레드가 동시에 접근 가능하도록 제한 |
| 소유권 | 특정 스레드가 락을 소유하며, 해당 스레드만 해제 가능 | 공유 자원에 대한 접근을 허용하는 카운터 값이 있으며, 특정 스레드가 소유하는 개념이 아님 |
| 어떤 상황에서 사용 | 단일 스레드가 자원에 접근해야 하는 경우. 예를 들어 **파일 쓰기, 은행 계좌 출금**과 같이 하나의 프로세스만 실행되어야 하는 작업에서 사용 | 여러 개의 스레드가 제한된 개수의 자원을 공유해야 할 때. 예를 들어 데이터베이스 **커넥션 풀, 스레드 풀**에서 사용 |
| 예시 | Java의 `synchronized` 키워드를 사용한 임계 영역 보호, `ReentrantLock` 을 이용한 락 관리 | Java의 `Semaphore` 클래스를 사용하여 최대 `N` 개의 스레드만 접근 허용 (`semaphore.acquire()` / `semaphore.release()` ) |
- 뮤텍스는 한 번에 하나의 스레드만 자원에 접근할 수 있도록 제한하며, 소유권을 가진 스레드만 락을 해제할 수 있음.
- 세마포어는 여러 개의 스레드가 공유 자원에 접근할 수 있도록 허용하며, 일정 개수의 스레드만 접근하도록 제한할 수 있음.
- 뮤텍스는 상호 배제(Mutual Exclusion)를 보장하며, 세마포어는 동시성을 제어하는 역할을 함.
- 뮤텍스는 주로 단일 스레드 보호가 필요한 곳에서 사용되며, 세마포어는 여러 개의 스레드가 제한된 자원을 공유할 때 사용됨.


<br>

### 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.

조건 변수는 특정 조건이 충족될 때까지 스레드를 대기 상태로 만들고, 조건이 충족되면 실행을 재개하도록 하는 동기화 기법.

**뮤텍스와의 협력 관계**

- 뮤텍스는 상호 배제를 보장하지만, 단순히 락만으로는 특정 조건이 충족될 때까지 효율적으로 기다릴 방법이 없음.
- 조건 변수를 활용하면 스레드가 불필요하게 CPU를 소비하지 않고 대기할 수 있음.

```java
class SharedResource {
    private boolean available = false;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void waitForCondition() throws InterruptedException {
        lock.lock();
        try {
            while (!available) {
                condition.await(); // 조건 충족될 때까지 대기
            }
            System.out.println("Condition met, proceeding...");
        } finally {
            lock.unlock();
        }
    }

    public void signalCondition() {
        lock.lock();
        try {
            available = true;
            condition.signal(); // 대기 중인 스레드 하나를 깨움
        } finally {
            lock.unlock();
        }
    }
}

```

<br>

### 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.

**데드락 발생 조건**

1. **상호 배제 (Mutual Exclusion)**: 하나의 자원은 한 번에 하나의 프로세스만 사용할 수 있음.
2. **점유 대기 (Hold and Wait)**: 프로세스가 자원을 점유한 상태에서 추가 자원을 기다림.
3. **비선점 (No Preemption)**: 할당된 자원을 강제로 빼앗을 수 없음.
4. **순환 대기 (Circular Wait)**: 여러 프로세스가 서로의 자원을 기다리며 원형으로 연결됨.

**데드락 예방 방법**

1. **락 순서 지정 (Lock Ordering)**: 자원을 항상 동일한 순서로 획득하여 순환 대기를 방지.
2. **타임아웃 설정 (Timeouts)**: 일정 시간 동안 자원을 획득하지 못하면 요청을 취소하고 다시 시도.
3. **은행가 알고리즘 (Banker’s Algorithm)**: 시스템의 안전 상태를 분석하여 자원 할당 여부를 결정.

<br>

### 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.

낙관적 락은 기본적으로 트랜잭션이 충돌 없이 성공할 것이라는 전제하에 성능을 최적화함. 그러나 충돌이 빈번하게 발생하면 성능이 급격히 저하될 수 있음.

1. **재시도 비용 증가**
    - 충돌이 발생할 때마다 트랜잭션이 롤백되고 재시도해야 하기 때문에 성능이 저하됨.
    - 충돌 빈도가 높을수록 불필요한 트랜잭션 실행 횟수가 증가하여 데이터베이스 부하가 커짐.
2. 불필요한 연산 낭비
    - 트랜잭션이 최종적으로 충돌하여 롤백되더라도, 처음부터 모든 연산을 수행한 후에야 충돌 여부를 확인함.
    - 만약 고빈도 업데이트 작업이 존재하는 환경이라면, 트랜잭션이 자주 실패하여 비효율적인 리소스 사용이 발생함.
3. 사용자 경험 저하
    - 애플리케이션에서 낙관적 락을 사용할 경우, 사용자가 입력한 데이터가 예상치 못하게 롤백될 가능성이 높아짐.
    - 예를 들어, 쇼핑몰의 주문 시스템에서 결제 도중 재고가 변경되면, 사용자는 구매 요청을 여러 번 시도해야 할 수 있음.

즉, 충돌이 적을 경우 낙관적 락이 효과적이지만, 충돌이 빈번하면 성능이 오히려 비관적 락보다 더 나빠질 수 있음. 따라서 낙관적 락을 사용할 환경에서는 충돌 가능성을 사전에 분석하고 적용해야 함.

| **구분** | **장점** | **단점** |
| --- | --- | --- |
| **성능** | 충돌이 적을 경우 락 없이 실행 가능하여 성능이 뛰어남 | 충돌이 많을 경우 트랜잭션 롤백이 자주 발생하여 성능 저하 |
| **데드락(Deadlock) 방지** | 락을 사용하지 않으므로 데드락이 발생하지 않음 | 충돌이 많을 경우 트랜잭션 재시도로 인해 전체적인 응답 속도가 느려질 수 있음 |
| **사용 사례** | 읽기 연산이 많고 쓰기 연산이 적은 환경 (예: 사용자 프로필 조회) | 다중 사용자가 동시에 데이터를 수정하는 환경 (예: 상품 재고 업데이트) |

<br>

### 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.

1. **세마포어를 활용한 자원 관리**
    - **최대 동시 접근 수 제한**

      데이터베이스 커넥션 풀에서는 동시에 사용할 수 있는 최대 연결 수를 제한해야 함. 세마포어를 활용하면 **설정된 개수 이상의 연결 요청이 발생할 경우 대기 상태로 유지**하도록 설계할 수 있어, 데이터베이스 과부하를 방지할 수 있음.

    - **자원 경합 방지**

      여러 스레드가 동시에 자원을 요청하는 경우, 세마포어를 통해 동기화를 보장하면 **경쟁 상태(Race Condition)를 방지**할 수 있음. 이를 통해 데이터 무결성을 유지하고, 예상치 못한 충돌을 줄일 수 있음.

    - **자원 할당 및 해제 관리**

      세마포어를 활용하면 **자원을 명확하게 할당하고, 사용이 끝난 후 반환**할 수 있도록 제어할 수 있음. 이를 통해 자원이 장시간 점유되는 것을 방지하고, **효율적인 자원 순환**이 가능해짐.


2. **세마포어의 장점과 효율성 향상 방안**
    - **자원 고갈 방지**

      세마포어를 활용하면 특정 개수 이상의 자원 요청을 차단하여 **시스템 과부하를 방지**

    - **공정한 자원 분배**

      `new Semaphore(n, true)` 처럼 **세마포어를 공정 모드 (fair mode)로 설정**하면, 대기 중인 스레드가 순서대로 자원을 할당받을 수 있어 공정한 자원 관리 가능

    - **오버헤드 감소**

      복잡한 락 메커니즘 대신, 세마포어를 활용하면 **더 적은 오버헤드**로 동기화가 가능하여 **성능 저하를 최소화**할 수 있음.


```java
import java.util.concurrent.Semaphore;

public class ConnectionPool {
    private final Semaphore semaphore;

    public ConnectionPool(int poolSize) {
        this.semaphore = new Semaphore(poolSize, true);
    }

    public void acquireConnection() throws InterruptedException {
        semaphore.acquire();  // 사용 가능한 커넥션이 있을 때만 접근 가능
        System.out.println("Connection acquired.");
    }

    public void releaseConnection() {
        semaphore.release();  // 사용이 끝난 후 반환
        System.out.println("Connection released.");
    }
}
```

<br>

### JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?

JavaScript는 싱글 스레드 기반이므로 비동기 작업이 많아질 경우 동시성 이슈 발생 가능. 공유 상태를 안전하게 관리하는 것이 중요함.

1. **비동기 작업의 순차적 처리**
    - `async/await` 를 사용하여 비동기 작업을 동기 코드처럼 순차적으로 처리 가능. 작업 순서를 제어하고, 동시성 문제 예방 가능

    ```jsx
    async function updateState() {
        const result1 = await asyncTask1();
        const result2 = await asyncTask2();
        // 결과를 사용하여 상태 업데이트
    }
    ```

    - `asyncTask1` 이 완료된 후에 `asyncTask2` 가 실행되어 순차적인 작업 처리가 가능함.
2. **상태 관리 라이브러리 활용**
    - 상태 관리 라이브러리를 사용하여 상태를 중앙에서 관리하고, 상태 변경을 일관되게 처리할 수 있음. 상태 변경 시 발생할 수 있는 동시성 문제 완화 가능
    - **Redux**: 액션과 리듀서를 통해 상태 변경을 예측 가능하게 관리
    - **Recoil**: 상태를 atom 단위로 관리하여 컴포넌트 간의 상태 의존성을 효율적으로 처리
3. **뮤텍스와 같은 동기화 메커니즘 도입**
    - 뮤텍스를 사용하여 한 번에 하나의 작업만 특정 자원에 접근하도록 제한. 공유 자원에 대한 동시 접근으로 인한 문제 방지.

    ```jsx
    class Mutex {
        constructor() {
            this.locked = false;
            this.queue = [];
        }
    
        lock() {
            return new Promise(resolve => {
                if (this.locked) {
                    this.queue.push(resolve);
                } else {
                    this.locked = true;
                    resolve();
                }
            });
        }
    
        unlock() {
            if (this.queue.length > 0) {
                const nextResolve = this.queue.shift();
                nextResolve();
            } else {
                this.locked = false;
            }
        }
    }
    
    const mutex = new Mutex();
    
    async function criticalSection() {
        await mutex.lock();
        // 공유 자원에 대한 작업 수행
        mutex.unlock();
    }
    ```

### 오늘의 회고
- 정리할 내용이 너무 많다. 전공책도 다시 봐야 할 듯.