# TIL

## 날짜: 2025-02-12

### 스크럼
- 학습 목표 1 : web에 대한 이해, 클라이언트/서버, 프로토콜, TCP/UDP, HTTP/HTTPS, Rest API

### 새로 배운 내용

| 구분 | 정의 | 비고 |
| --- | --- | --- |
| 클라이언트 - 서버 | 클라이언트가 요청을 보내고, 서버가 이를 처리하여 응답하는 네트워크 아키텍처. 중앙 집중형 구조로 관리가 용이하며, 확장성이 높음. | 서버 부하 분산을 위해 로드 밸런서를 활용할 수 있으며, 클라이언트-서버 모델의 대안으로 P2P 모델이 존재함. |
| DNS | 도메인 네임 시스템으로, 사람이 이해하기 쉬운 도메인 이름을 IP 주소로 변환하여 네트워크 통신을 가능하게 함. 계층적 구조로 운영됨. | DNS 캐싱, DNS 스푸핑 공격 방지 기법 (DNSSEC) 등에 대한 이해가 필요함. |
| OSI 7계층 | 네트워크 통신을 7개의 계층(물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용)으로 나누어 역할을 분리한 개념적 모델. | 실질적인 인터넷 프로토콜 구조는 OSI 모델이 아닌 TCP/IP 4계층 구조를 기반으로 설계됨. |
| TCP | 신뢰성 있는 데이터 전송을 보장하는 연결 지향 프로토콜. 데이터의 순서 보장, 오류 검출 및 재전송, 흐름 제어 등의 기능을 제공. | TCP와 비교하여 속도 중심의 비연결형 프로토콜인 UDP를 함께 학습하면 이해가 쉬움. |
| TCP/3way-handshake | TCP 연결 설정 과정으로, SYN → SYN-ACK → ACK 3단계를 거쳐 연결을 수립함. 이를 통해 신뢰성 있는 데이터 전송이 가능해짐. | SYN Flooding과 같은 DoS 공격을 방지하기 위한 SYN 쿠키 기법이 존재함. |
| TCP/흐름제어, 혼잡제어 | 흐름 제어는 수신자의 처리 속도를 초과하지 않도록 조절하며, 혼잡 제어는 네트워크 과부하를 방지하기 위한 기법. | 윈도우 크기는 네트워크 상태 및 수신자의 버퍼 크기에 따라 동적으로 조정됨. |
| TCP/슬라이딩 윈도우 | 송신자가 미리 정해진 크기의 데이터(윈도우 크기)를 수신자이 ACK 없이 전송할 수 있도록 하는 메커니즘. | 윈도우 크기는 네트워크 상태 및 수신자의 버퍼 크기에 따라 동적으로 조정됨. |
| TCP/slow start | 초기 전송 속도를 낮게 설정하고 네트워크 상태에 따라 점진적으로 증가시키는 혼잡 제어 알고리즘. | 혼잡 회피, 빠른 재전송과 함께 사용됨. |
| UDP | 신뢰성보다 속도를 우선하는 비연결형 프로토콜. 패킷 손실 감지 및 복구가 필요하지 않은 서비스에 적합. | 실시간 스트리밍, 온라인 게임, VoIP(인터넷 전화) 등에 활용됨. |
| CDN | 콘텐츠를 여러 서버에 분산 저장하여 사용자와 가까운 서버에서 제공함으로써 로딩 속도를 향상시키는 기술. | 글로벌 기업들은 Cloudflare, Akamai, AWS CloudFront 등의 CDN 서비스를 이용함. |
| HTTP / HTTPS | HTTP는 하이퍼텍스트 전송을 위한 프로토콜이며, HTTPS는 TLS/SSL을 통해 보안이 강화된 HTTP 버전. | HTTP/2는 멀티플렉싱을 지원하며, HTTP/3는 QUIC 기반으로 전송됨. |
| HTTP Method 요청의 종류 | HTTP 요청을 위한 메서드로, GET(조회), POST(생성), PUT(수정), DELETE(삭제) 등이 존재함. | PATCH는 리소스의 일부만 수정할 때 사용됨. |
| HTTP 상태 코드 | 서버 응답의 상태를 나타내는 코드. 2xx(성공), 3xx(리다이렉션), 4xx(클라이언트 오류), 5xx(서버 오류)로 분류됨. | 439 Too Many Requests는 API Rate Limiting을 의미함. |
| TLS / SSL | 인터넷 보안을 위한 암호화 프로토콜. TLS는 SSL의 개선된 버전이며, 현재는 TLS 1.3이 가장 최신 버전. | SSL은 보안 취약점으로 인해 더 이상 사용되지 않으며, TLS가 표준임. |
| QUIC, HTTP 버전별 특징 비교 | HTTP/1.1은 순차적 요청 처리, HTTP/2는 멀티플렉싱 지원, HTTP/3은 QUIC을 기반으로 더욱 빠른 성능 제공. | QUIC는 UDP 기반 프로토콜로, TCP의 3-way handshake 지연 문제를 해결함. |
| HTTP/2 Multiplexing | 하나의 TCP 연결에서 여러 요청을 동시에 처리할 수 있도록 하는 HTTP/2의 기능. | HOL(Head-of-Line) Blocking 문제를 해결하는데 기여함. |
| 대칭키, 비대칭키 암호화 방식 | 대칭키는 하나의 키를 공유하여 암호화/복호화를 수행하고, 비대칭키는 공개키와 개인키를 사용하여 보안성을 높임. | 대칭키: AES, 비대칭키: RSA, ECC 등의 알고리즘이 사용됨. |
| HTTP Cache | 웹 응답 데이터를 클라이언트 또는 중간 서버에 저장하여 반복 요청 시 속도를 향상시키는 기법. | Cache-Control, ETag, Last-Modified 헤더를 활용하여 캐싱을 관리함. |
| API | 애플리케이션 간 데이터 및 기능을 주고받을 수 있도록 제공되는 인터페이스. | SOAP, REST, GraphQL, gRPC 등의 다양한 API 스타일이 존재함. |
| API Gateway | 여러 API 요청을 중앙에서 관리하는 역할을 하는 서버. 인증, 로깅, 요청 라우팅 등의 기능을 제공. | 주요 API Gateway 솔루션: Kong, AWS API Gateway, Nginx |
| REST 아키텍처 스타일 | HTTP 기반으로 리소스를 관리하는 아키텍처 스타일. 리소스는 URI로 식별되며, HTTP 메서드를 활용하여 조작됨. | RESTful API는 무상태성을 가지며, 클라이언트-서버 모델을 기반으로 함. |
| REST API | REST 원칙을 따르는 API. HTTP 요청을 통해 데이터를 송수신하며 JSON 형식이 일반적으로 사용됨. | gRPC와 같은 API 스타일과 비교하면 속도와 성능 차이를 이해할 수 있음. |

### 1. TCP 프로토콜이 어떻게 신뢰성을 보장하는지 설명해주세요. (or 신뢰성 보장을 위해 사용하는 매커니즘들을 설명해주세요.)

1. **연결 설정 (Connection Establishment)**
    - TCP는 3-Way Handshake를 사용하여 신뢰성 있는 연결을 설정함.
    - 과정
        1. 클라이언트가 서버에 `SYN` 패킷을 보냄.
        2. 서버는 `SYN-ACK` 응답을 보냄.
        3. 클라이언트가 `ACK` 를 보내면서 연결이 성립됨.
    - 이를 통해 양쪽 모두 데이터 전송을 준비했음을 보장함.

2. **순서 보장 (Sequencing)**
    - TCP는 데이터 패킷마다 순서 번호(Sequence Number)를 부여하여, 전송된 데이터의 순서를 보장함.
    - 수신자는 패킷이 순서대로 도착했는지 확인하고, 순서가 어긋난 경우 재정렬하여 정상적인 데이터 스트림을 유지함.

3. **흐름 제어 (Flow Control)**
    - 송신자가 수신자의 처리 속도보다 빠르게 데이터를 전송하는 것을 방지하기 위해 슬라이딩 윈도우(Sliding Window) 프로토콜을 사용함.
    - 수신자는 `윈도우 크기(Window Size)` 를 지정하여, 현재 수용할 수 있는 데이터 크기를 송신자에게 알림.
    - 송신자는 이 정보를 기반으로 전송 속도를 조절함.

4. **혼잡 제어 (Congestion Control)**
    - 네트워크가 혼잡해지는 것을 방지하기 위해 TCP는 여러 가지 혼잡 제어 알고리즘을 사용함.
    - 주요 알고리즘
        - **Slow Start**: 처음에는 작은 윈도우 크기로 전송을 시작하고, 점진적으로 크기를 증가시킴.
        - **Congestion Avoidance**: 패킷 손실이 감지되지 않으면 선형적으로 윈도우 크기를 증가.
        - **Fast Retransmit & Fast Recovery**: 패킷 손실을 감지하면 즉시 재전송하여 성능을 개선.

5. **오류 검출 및 재전송 (Error Detection & Retransmission)**
    - TCP는 데이터의 무결성을 보장하기 위해 체크섬(Checksum)을 사용하여 패킷의 오류를 감지함.
    - 패킷이 손상되었거나 손실된 경우, 수신자는 중복 ACK(Duplicate ACK) 또는 타이머 기반 재전송(Retransmission Timeou, RTO)을 통해 송신자에게 재전송을 요청함.

6. **ACK(응답 확인) 및 재전송 (Acknowledgment & Retransmission)**
    - 수신자는 데이터 패킷을 정상적으로 수신하면 ACK 패킷을 송신자에게 보냄.
    - 만약 일정 시간 내에 ACK가 오지 않으면 송신자는 데이터를 다시 전송함.
    - TCP는 누적 ACK 방식을 사용하여 여러 패킷을 한 번에 확인할 수도 있음.

7. **연결 해제 (Connection Termination)**
    - TCP는 4-way Handshake를 사용하여 신뢰성 있게 연결을 종료함.
    - 과정
        1. 클라이언트가 `FIN` 패킷을 전송하여 종료 요청.
        2. 서버는 `ACK` 로 응답.
        3. 서버가 종료 준비가 되면 `FIN` 패킷을 전송.
        4. 클라이언트가 `ACK` 를 전송하면서 연결이 종료됨.
    - 이를 통해 송신 중인 데이터가 모두 정상적으로 전송된 후 연결이 종료됨을 보장함.

### 2. TCP와 UDP의 차이점을 설명해주세요.

TCP와 UDP는 모두 전송 계층(Transport Layer)에서 동작하는 프로토콜이지만, 각각의 특성과 목적이 다름.

| **프로토콜** | **설명** |
| --- | --- |
| **TCP (Transmission Control Protocol)** | 신뢰성을 보장하는 연결 지향형 프로토콜로, 데이터의 순서 보장, 오류 검출 및 복구, 흐름 제어 등을 제공. |
| **UDP (User Datagram Protocol)** | 신뢰성보다는 속도를 우선하는 비연결형 프로토콜로, 데이터그램 방식 전송. 패킷 손실이 발생해도 복구하지 않음. |

---

| **비교 항목** | **TCP**                                                                    | **UDP** |
| --- |----------------------------------------------------------------------------| --- |
| **연결 방식** | **연결 지향(Connection-oriented)** <br> 3-way Handshake를 통해 연결을 설정한 후 데이터 전송   | **비연결형(Connectionless)** <br> 데이터를 바로 전송하며 연결 설정 과정 없음 |
| **신뢰성** | 신뢰성 보장 (순서 보장, 재전송, 오류 검출)                                                 | 신뢰성 없음 (순서 보장X, 손실 시 복구X) |
| **데이터 전송 방식** | 스트림(Stream) 기반                                                             | 데이터그램(Datagram) 기반 |
| **전송 순서 보장** | 시퀀스 번호를 사용하여 데이터 순서 보장                                                     | 순서 보장 없음 |
| **흐름 제어 (Flow Control)** | 슬라이딩 윈도우(Sliding Window) 기반으로 수신자의 처리 속도를 고려하여 전송                          | 없음 |
| **혼잡 제어 (Congestion Control)** | 네트워크 혼잡을 감지하고 전송 속도를 조절 (Slow Start, AIMD 등 사용)                            | 없음 |
| **오버헤드** | 높은 오버헤드 (핸드셰이크, ACK, 혼잡 제어 등으로 인한 추가 데이터 발생)                               | 낮은 오버헤드 (추가적인 제어 데이터가 거의 없음) |
| **속도** | 상대적으로 느림                                                                   | 빠름 |
| **패킷 손실 처리** | 손실 시 자동 재전송                                                                | 손실 발생 시 복구하지 않음 |
| **사용 예시** | 웹 브라우징(HTTP, HTTPS), 이메일(SMTP, IMAP, POP3), 파일 전송(FTP), 원격 접속(SSH, Telnet) | 실시간 스트리밍(Video, VoIP), 온라인 게임, DNS, DHCP |

### 3. 3way-handshake의 과정에 대해서 설명해주세요(or 왜 필요한건지 설명해주세요.)

1. **SYN (Synchronization) - 클라이언트가 서버에 연결 요청**
    - 클라이언트(요청하는 측)가 서버(응답하는 측)에 연결을 시작하고 싶다는 의미로 SYN 패킷을 보냄.
    - 이때, 초기 시퀀스 번호 (Initial Sequence Number, ISN)를 포함하여 전송.
    - 예) `SYN(seq=100)`

2. **SYN-ACK (Synchronization + Acknowledgment) - 서버가 요청을 수락**
    - 서버는 클라이언트의 요청을 받으면 SYN-ACK 패킷을 보냄.
    - 여기에는 자신의 초기 시퀀스 번호(ISN)와 클라이언트의 요청을 확인했다는 ACK(응답 번호)이 포함됨.
    - 예) `SYN(seq=300) + ACK(seq=101)`

3. **ACK (Acknowledgment) - 클라이언트가 응답을 확인하고 연결 확립**
    - 클라이언트는 서버의 SYN-ACK 응답을 받으면, ACK 패킷을 다시 서버에게 보냄.
    - 이로써 연결이 정상적으로 확립됨.
    - 예) `ACK(seq=301)`

- 3-way Handshake가 필요한 이유
    - 데이터 전송 전 연결 상태를 확인하기 위해
        - 클라이언트와 서버가 서로 데이터를 송수신할 준비가 되었는지 확인하는 과정이 필요함.
        - 단순히 요청을 보내는 것이 아니라 네트워크 상태가 정상인지 체크하여 신뢰성을 확보함.
    - 패킷 손실을 방지하기 위해
        - 네트워크 환경에서 패킷이 손실되거나 순서가 어긋나는 문제를 방지할 수 있음.
        - 연결이 성립되었음을 명확하게 확인한 후 데이터를 전송하기 때문에 데이터 유실 없이 안정적으로 통신 가능.
    - 시퀀스 번호를 동기화하기 위해
        - TCP는 데이터의 순서를 보장해야 하므로, 송신자와 수신자가 각자의 초기 시퀀스 번호를 주고받아 패킷의 순서를 유지함.
        - 이를 통해 패킷이 중복되거나 잘못된 데이터가 전달되지 않도록 방지함.
    - 서버 자원 낭비를 방지하기 위해
        - 서버가 무작위로 오는 요청을 무조건 수락하면, 불필요한 연결이 생성되어 리소스 낭비가 발생할 수 있음.
        - 3-way Handshake를 통해 실제 통신할 의사가 있는 클라이언트만 연결을 허용하여 서버의 부하를 줄임.

### 4. HTTP Method는 어떤것들이 있으며 각각 언제 사용되나요?

HTTP는 클라이언트와 서버 간의 요청과 응답을 처리하는 프로토콜이며, HTTP 메서드는 클라이언트가 서버에 특정 작업을 요청할 때 사용됨.

| **메서드** | **설명** | **주요 사용 사례** |
| --- | --- | --- |
| **GET** | 서버에서 데이터를 조회할 때 사용 | 웹페이지 조회, 검색 결과 요청 |
| **POST** | 서버에 새로운 리소스를 생성할 때 사용 | 회원 가입, 데이터 업로드, 로그인 |
| **PUT** | 서버의 기존 리소스를 완전히 교체할 때 사용 | 사용자 프로필 전체 업데이트 |
| **PATCH** | 서버의 기존 리소스를 부분적으로 수정할 때 사용 | 비밀번호 변경, 일부 정보 수정 |
| **DELETE** | 서버에서 리소스를 삭제할 때 사용 | 게시글 삭제, 계정 삭제 |
| **HEAD** | GET과 유사하지만 응답 본문을 제외하고 헤더만 반환 | 리소스가 존재하는지 확인 (예: 404 검사) |
| **OPTIONS** | 서버에서 지원하는 HTTP 메서드 목록을 반환 | CORS(교차 출처 요청) 확인 |
| **CONNECT** | 대상 서버와의 터널링을 설정할 때 사용 | 프록시 서버를 통한 SSL 연결 |
| **TRACE** | 클라이언트-서버 간 경로를 추적할 때 사용 | 네트워크 디버깅 |

### 5. 3-way Handshake 이후에 TCP 연결을 종료하는 과정(4-way Handshake)을 설명해주세요.

1. **클라이언트가 연결 종료 요청 (FIN)**
    - 데이터 전송이 완료되면 클라이언트가 `FIN (Finish)` 패킷을 전송하여 연결을 종료하고 싶다는 요청을 보냄.
    - 서버는 즉시 연결을 끊지 않고, 현재 처리 중인 데이터를 마무리할 수 있도록 대기 상태에 들어감.

2. **서버가 종료 요청을 확인하고 ACK 전송**
    - 서버는 `ACK (Acknowledgment)` 패킷을 보내서 클라이언트의 FIN 요청을 확인했음을 응답함.
    - 하지만 서버는 아직 전송해야 할 데이터가 남아 있을 수도 있으므로, 이 단계에서는 연결이 유지됨.

3. **서버도 연결 종료 요청 (FIN)**
    - 서버가 모든 데이터를 전송하고 나면, 서버도 클라이언트에게 FIN 패킷을 전송하여 연결 종료 요청을 보냄.
    - 이때, 클라이언트가 이전 단계에서 보낸 `ACK` 과는 별개의 요청임.

4. **클라이언트가 종료 요청을 확인하고 최종 ACK 전송**
    - 클라이언트는 서버의 `FIN` 요청을 확인한 후, 마지막으로 `ACK` 패킷을 전송하여 서버의 종료 요청을 승인함.
    - 이후 일정 시간(TIME-WAIT) 동안 대기한 후 연결이 완전히 종료됨.

### 6. 흐름 제어와 혼잡 제어의 차이는 무엇이며, TCP에서 각각 어떻게 적용되나요?

- **흐름 제어(Flow Control)**: 송신자와 수신자 간 속도 차이를 조절하여 수신자의 버퍼 오버플로우를 방지.
- **혼잡 제어(Congestion Control)**: 네트워크 내 혼잡 발생을 방지하기 위해 송신자의 데이터 전송 속도를 조절.

| **비교 항목** | **흐름 제어 (Flow Control)** | **혼잡 제어 (Congestion Control)** |
| --- | --- | --- |
| **목적** | 수신자가 처리할 수 있는 속도로 데이터를 전송하도록 조절 | 네트워크 혼잡을 방지하여 패킷 손실을 최소화 |
| **대상** | 송신자와 수신자 간 조절 | 네트워크 전체의 트래픽 조절 |
| **원인** | 수신자의 버퍼 크기 부족 | 네트워크 트래픽 증가로 인한 혼잡 (패킷 손실, 지연 증가) |
| **해결 방법** | 수신자가 윈도우 크기 (Window Size) 조절 | 송신자가 혼잡 상태를 감지하고 전송 속도를 조절 |
| **TCP 적용 방식** | 슬라이딩 윈도우 (Sliding Window) | Slow Start, AIMD, Fast Retransmit, Fast Recovery |

### 7. xx님이 생각하는 Restful한 API에 대해서 설명해주세요.

REST (Representational State Transfer) 원칙을 준수하여 설계된 API를 의미함. REST는 웹 서비스 아키텍처 스타일 중 하나로, HTTP 프로토콜을 기반으로 자원의 표현(Representation)과 상태(State)를 전송(Transfer)하는 방식을 따름.

즉, RESTful한 API는 클라이언트와 서버 간의 통신을 일관된 방식으로 설계하여, 확장성과 유지보수성이 높은 API를 의미함. RESTful API는 주로 웹 서비스 및 마이크로서비스에서 사용됨.

### 8. RESTful API란 무엇이며, 어떤 특징을 갖나요?

RESTful API는 웹 서비스 간의 상호 작용을 REST 원칙에 맞게 설계한 API.

- RESTful API 특징
    - 클라이언트 - 서버 구조
        - 클라이언트와 서버가 역할을 분리하여 독립적으로 동작해야 함.
        - 서버는 데이터 저장 및 비즈니스 로직 처리, 클라이언트는 UI 및 사용자 인터페이스 담당.
        - 이를 통해 시스템의 확장성과 유연성이 향상됨.
    - 무상태성 (Stateless)
        - 서버는 클라이언트의 상태(Session)를 저장하지 않음.
        - 모든 요청은 독립적이며, 필요한 정보를 포함해야 함.
        - 따라서 수평 확장(Scaling)이 용이하고, 로드 밸런싱이 가능함.
    - 자원(Resource) 기반 URI (Uniform Interface)
        - RESTful API의 URI는 명확하고 직관적이어야 함.
        - 리소스를 식별하는 경로를 사용하고, 행위를 포함하면 안 됨.
        - HTTP 메서드(`GET` , `POST` , `PUT` , `DELETE` )와 조합하여 의미를 전달.
    - HTTP 메서드 활용
    - HATEOAS (Hypermedia As The Engine Of Application State)
        - API 응답이 관련된 API 경로를 포함하여, 클라이언트가 탐색 가능해야 함.
        - 즉, API가 어떤 요청을 추가적으로 할 수 있는지 안내해야 함.
    - 계층화된 시스템 (Layered System)
        - 클라이언트와 서버 간에 프록시, 게이트웨이, 로드 밸런서 등을 추가할 수 있어야 함.
        - API 요청이 보안, 캐싱, 로깅 계층을 거쳐 처리될 수 있도록 설계.

### 9. 대칭키와 비대칭키 암호화 방식에 대해서 설명해주세요.

- 대칭키
    - 하나의 키(Secret Key)를 사용하여 암호화와 복호화를 수행하는 방식.
    - 송신자와 수신자가 동일한 키를 공유해야 하므로, 키의 보안이 중요.
    - 연산 속도가 빠르며, 대량의 데이터를 암호화하는 데 적합.
    - 동작 방식
        1. 송신자는 공유된 키를 사용하여 데이터를 암호화
        2. 수신자는 같은 공유된 키를 사용하여 데이터를 복호화.
    - 장점
        - 연산 속도가 빠름
        - 구현이 간단
        - 대량의 데이터 암호화에 적합
    - 단점
        - 키 공유 문제 → 키가 노출되면 보안 위협 발생
        - 확장성 부족 → 여러 사용자 간 키를 안전하게 공유하는 것이 어려움.
    - 주요 알고리즘
  
      | **알고리즘** | **설명** |
      | --- | --- |
      | AES (Advanced Encrption Standard) | 가장 널리 사용되는 고급 암호화 표준 (128, 192, 256비트 키 사용) |
      | DES (Data Encryption Standard) | 56비트 키를 사용하는 초기 암호화 표준 (현재는 보안 취약) |
      | 3DES (Triple DES) | DES를 세 번 반복하여 보안을 강화한 버전 |
      | RC4 | 스트림 암호화 방식 (현재는 사용 권장되지 않음) |

- 비대칭키
    - 두 개의 키(공개키 & 개인키)를 사용하여 암호화와 복호화 수행.
    - 공개키로 암호화하면, 개인키로만 복호화 가능.
    - 공개키는 공개할 수 있지만, 개인키는 절대 유출하면 안 됨.
    - 키 공유 문제를 해결할 수 있지만, 대칭키보다 속도가 느림.
    - 동작 방식.
        1. 송신자는 수신자의 공개키를 사용하여 데이터를 암호화.
        2. 수신자는 개인키를 사용하여 암호문을 복호화.
    - 장점
        - 키 공유 문제 해결 → 공개키는 누구나 사용할 수 있어 안전한 키 분배 가능.
        - 디지털 서명 적용 가능 → 전자 서명 및 인증 시스템에 사용됨.
        - 보안성이 높음 → 개인키가 유출되지 않는 한 안전함.
    - 단점
        - 연산 속도가 느림 → 대칭키 암호화보다 처리 속도가 느림.
        - 대량 데이터 암호화에 부적함 → 주로 키 교환 및 서명에 사용됨.
    - 주요 알고리즘

        | **알고리즘** | **설명** |
        | --- | --- |
        | RSA (Rivest-Shamir-Adleman) | 가장 널리 사용되는 비대칭 암호화 알고리즘 (키 길이 1024, 2048, 4096 비트) |
        | ECC (Elliptic Curve Crptography) | RSA보다 짧은 키 길이로 높은 보안을 제공하는 알고리즘 |
        | DSA (Digital Signature Algorithm) | 전자 서명 전용 알고리즘 |
        | Diffie-Hellman (DH) | 비대칭키 기반의 키 교환 알고리즘 (암호화 자체는 아님) |