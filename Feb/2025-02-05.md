# TIL

## 날짜: 2025-02-05

### 스크럼
- 학습 목표 1 : 동기/비동기, 블록킹/논블록킹

### 새로 배운 내용

| **구분** | **정의**                                                                                                                 | **비고**                                                                                                                    |
| --- |------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|
| **동기 / 비동기** | **- 동기(Synchronoous)**: 요청을 보낸 후 응답이 올 때까지 기다리는 방식. <br>- **비동기(Asynchronous)**: 요청을 보낸 후 응답을 기다리지 않고 다음 작업을 수행하는 방식. | - 동기는 처리 순서를 보장하지만 속도가 느릴 수 있음. <br>- 비동기는 빠른 처리가 가능하지만 응답을 기다리는 로직을 고려해야 함.                                              |
| **블로킹 / 논블로킹** | **- 블로킹(Blocking)**: 호출된 함수가 실행을 완료할 때까지 스레드가 대기하는 방식. <br>- **논블로킹(Non-Blocking)**: 호출된 함수가 즉시 반환되어 다른 작업을 수행할 수 있는 방식. | - 블로킹은 단순하지만 성능 저하 가능성이 있음. <br>- 논블로킹은 효율적이지만 호출한 쪽(caller)에서 복잡한 동작 제어가 필요할 수 있음. 호출된 쪽(callee, 즉 함수 내부 구현)은 상대적으로 단순함. |

#### 1. 동기 / 비동기의 차이를 설명하고 파일 읽기 작업을 예시로 들어 설명해주세요.
- **동기**: 작업을 순차적으로 수행하며, 하나의 작업이 완료된 후에야 다음 작업을 진행함. 호출한 함수는 호출된 함수의 작업이 끝날 때까지 기다림.
- **비동기**: 작업을 병렬적으로 처리하며, 호출된 함수의 작업 완료 여부와 상관없이 다음 작업을 진행함. 작업이 완료되면 콜백 함수나 Promise 등을 통해 결과를 처리함.
- **파일 읽기 작업 예시**
  - **동기적 파일 읽기**
    ```jsx
    const fs = require('fs');
    
    console.log("파일 읽기 시작");
    
     const data = fs.readFileSync('example.txt', 'utf8');
    console.log("파일 내용:", data);
    
    console.log("파일 읽기 완료");
    ```
    **실행 흐름**
    1. "파일 읽기 시작" 출력
    2. `readFileSync` 함수가 파일을 모두 읽을 때까지 대기
    3. 파일 내용을 출력
    4. "파일 읽기 완료" 출력
  - **비동기적 파일 읽기**
    ```jsx
    const fs = require('fs');
            
    console.log("파일 읽기 시작");
            
    fs.readFile('example.txt', 'utf8', (err, data) => {
        if (err) {
            console.error("파일 읽기 실패:", err);
            return;
        }
        console.log("파일 내용:", data);
    });
            
    console.log("파일 읽기 완료");
    ```
     **실행 흐름**
    1. "파일 읽기 시작" 출력
    2. `readFile` 함수 호출 후 바로 다음 코드 실행
    3. "파일 읽기 완료" 출력
    4. 파일 읽기가 완료되면 콜백 함수 실행하여 파일 내용 출력
  - 동기적 파일 읽기는 파일을 모두 읽을 때까지 프로그램이 대기하지만, 비동기적 파일 읽기는 파일을 읽는 동안에도 다른 작업을 계속 진행할 수 있음

#### 2. 블로킹과 논블로킹을 제어권 관점에서 설명해주세요.
- **블로킹**: 호출된 함수가 작업을 완료할 때까지 호출한 함수의 제어권을 가져서, 호출한 함수는 대기 상태에 놓임. 즉, 호출한 함수는 호출된 함수의 작업이 끝날 때까지 아무 작업도 수행하지 못함.
- **논블로킹**: 호출된 함수가 즉시 제어권을 호출한 함수에게 반환하여, 호출한 함수는 다른 작업을 계속 수행할 수 있음. 호출된 함수의 작업 완료 여부와 상관없이 호출한 함수는 자신의 작업을 이어나감.
- 위 파일 읽기 예시에서, 블로킹 방식은 파일을 모두 읽을 때까지 프로그램이 대기하지만, 논블로킹 방식은 파일을 읽는 요청을 보내고 바로 다음 작업을 수행함.

#### 3. 동기 + 블로킹과 동기 + 논블로킹 조합의 차이를 설명해주세요.
- **동기 + 블로킹**
  - 호출한 함수는 호출된 함수의 작업이 완료될 때까지 대기하며, 제어권도 호출된 함수가 가지고 있음.
  - 예) 전통적인 함수 호출로, 함수가 작업을 완료할 때까지 호출한 함수는 대기함.
- **동기 + 논블로킹**
  - 호출된 함수는 작업을 시작하고 즉시 제어권을 호출한 함수에게 반환. 그러나 호출한 함수는 작업의 완료 여부를 지속적으로 확인(polling)하며, 작업이 완료되기 전까지 다른 작업을 수행하지 않음.
  - 예) 논블로킹 I/O 작업 후, 작업의 완료 여부를 반복적으로 확인하는 방식.

#### 4. 비동기 I/O와 논블로킹 I/O는 같은 개념인가요? 두 개념이 어떻게 다르다고 생각하시나요?
비동기 I/O와 논블로킹 I/O는 종종 혼용되지만, 개념적으로 차이가 있음.
- **비동기 I/O**
  - 작업을 요청한 후, 해당 작업의 완료 여부를 호출한 함수가 신경 쓰지 않음. 대신, 작업이 완료되면 콜백 함수나 이벤트를 통해 결과를 전달받음.
  - 예) 파일 읽기 요청을 보내고, 작업이 완료되면 콜백 함수를 통해 결과를 받는 방식.
- **논블로킹 I/O**
    - 작업을 요청한 후, 호출된 함수는 즉시 제어권을 반환하여 호출한 함수가 다른 작업을 수행할 수 있게 함. 호출한 함수는 작업의 완료 여부를 지속적으로 확인(polling)하거나, 필요에 따라 다시 요청함.
    - 예) 파일 읽기 요청을 보내고, 작업이 완료되었는지 주기적으로 확인하는 방식.
- 요약하면, 비동기 I/O는 작업 완료를 호출된 함수가 관리하고, 논블로킹 I/O는 호출한 함수가 작업 완료 여부를 관리함.

#### 5. 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법은 어떤것이 있나요?
멀티스레드 환경에서 블로킹 I/O를 사용할 경우, 스레드가 I/O 작업을 기다리는 동안 다른 스레드로 전환되며 컨텍스트 스위칭이 발생함. 이는 시스템 자원 소모와 성능 저하의 원인이 될 수 있음. 이러한 오버헤드를 줄이기 위한 방법은 다음과 같음 ⇒
- **스레드 풀 (Thread Pool) 사용**
  - 새로운 스레드를 계속 생성하는 대신, 일정한 수의 스레드를 미리 만들어 재사용하면 스레드 생성 및 소멸에 따른 오버헤드를 줄일 수 있음. 스레드 풀을 사용하면 스레드 수를 제한하여 과도한 컨텍스트 스위칭을 방지하고, 시스템 자원을 효율적으로 관리할 수 있음.
- **비동기 I/O 또는 논블로킹 I/O 사용**
  - 블로킹 I/O 대신 비동기 또는 논블로킹 I/O를 사용하면, 스레드가 I/O 작업을 기다리지 않고 다른 작업을 수행할 수 있어 컨텍스트 스위칭 빈도를 줄일 수 있음. 예를 들어, Java의 NIO(New I/O) 라이브러리는 논블로킹 I/O를 지원하여 이러한 방식으로 오버헤드를 감소시킬 수 있음.
- **스레드 수 최적화**
  - 시스템의 CPU 코어 수와 작업 특성에 맞게 스레드 수를 조절하여 컨텍스트 스위칭을 최소화할 수 있음. 예를 들어, HikariCP와 같은 커넥션 풀에서는 스레드 수를 `(CPU 코어 수 * 2)+ 디스크 스핀들 수` 로 설정하는 것을 권장함.
- **락(lock) 사용 최소화**
  - 스레드 간 동기화를 위한 락의 사용을 최소화하여, 스레드 경합으로 인한 컨텍스트 스위칭을 줄일 수 있음. 불필요한 락을 제거하고, 락의 범위를 최소화하는 등의 최적화가 필요함.

#### 6. 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점은 어떤것이 있나요?
- **높은 동시성 처리**
  - 논블로킹 I/O는 하나의 스레드가 여러 I/O 작업을 동시에 처리할 수 있게 하여, 적은 수의 스레드로도 많은 클라이언트 요청을 효율적으로 처리할 수 있음. 이는 특히 대규모 트래픽을 처리하는 웹 서버에서 중요함.
- **낮은 자원 소비**
  - 블로킹 I/O 방식에서는 각 클라이언트 요청마다 별도의 스레드가 필요하지만, 논블로킹 I/O 방식에서는 소수의 스레드로 다수의 요청을 처리할 수 있어 메모리 및 CPU 자원 소비를 줄일 수 있음.
- **향상된 응답 시간**
  - 논블로킹 I/O를 사용하면 I/O 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있어, 전체적인 응답 시간이 단축됨. 이는 사용자 경험 향상에 기여함.
- **컨텍스트 스위칭 감소**
  - 스레드 수가 줄어들어 스레드 간 전환에 따른 컨텍스트 스위칭 오버헤드가 감소함. 이는 CPU 사용 효율을 높이고, 시스템의 전반적인 성능을 향상시킴.

예를 들어, NGINX 웹 서버는 논블로킹 I/O와 이벤트 기반 아키텍처를 사용하여 높은 성능과 확장성을 제공함. 이러한 구조 덕분에 NGINX는 수백만 개의 동시 연결을 효율적으로 처리할 수 있음.
   이러한 이유들로 인해, 현대의 많은 고성능 웹 서버와 프레임워크는 논블로킹 I/O 방식을 채택하고 있음.


### 오늘의 회고
- 동기/비동기, 블로킹/논블로킹 개념에 대해 깊게 파고 들어본 적이 없는데, 이번 기회에 확실히 알게 되었다.